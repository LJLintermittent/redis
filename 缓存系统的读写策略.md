###  Cache Aside Pattern （旁路缓存模式）

旁路缓存是平时系统中使用较多的一个缓存读写模式。比较适合读请求比较多的情况。在旁路缓存系统中，系统需要同时维持DB和cache。并且总是以DB结果为准。

旁路缓存模式：

写流程是：

1.先更新DB

2.在删除缓存

读流程是：

1.先从cache中读取，读到了直接返回

2.cache中没有去DB中读取

3.在将结果返回前要将结果加入缓存

如果在写的时候，先删缓存，在更新DB会有什么问题？

如果先删了缓存，还没有来得及写库，那么另一个线程来读取的时候，发现缓存为空，则去数据库中读取数据并加入缓存，此时缓存中的数据就变了脏数据，因为第一个线程这时候更更新数据库，从而造成了缓存与数据库中数据不一致的情况

如果先写了库，再删除缓存，如果写库的时候宕机了，没有删掉缓存，那么缓存中数据也是旧数据

对于这种模式的缓存数据不一致问题：无论是先删缓存在写库，还是先写库在删缓存，都是可能造成数据不一致的

解决方案：

一.延时双删和缓存超时

在写库前后都进行删除缓存的操作，并且设定合理的缓存过期时间，具体步骤就是：

1.先删除缓存

2.再写数据库

3.休眠一段时间

4.再次删除缓存

设置缓存过期时间，所有的写操作以数据库为准，只要达到缓存过期时间，则后面的读请求自动会从数据库取出新值，然后在回填缓存

二.异步更新缓存（基于订阅binlog的同步机制）

订阅mysql增量日志binlog进行消费+消息队列+增量数据更新到redis，一旦mysql产生了更新操作，就把binlog记录的相关信息的消息通过消息队列推送至redis服务，redis根据binlog中的内容，来对redis的缓存进行更新

后面一种方法应该是最终一致性的思想，强一致比如通过加分布式锁，确保写库删缓存这两个动作(无所谓顺序)是一个原子操作，这样能保证用户总是能读取到更新后的正确数据，但其实就缓存的使用场景来说，缓存主要使用在读多写少的业务中，来降低数据库的读取压力，同时对于要展示的缓存数据，一般在业务上都会允许很少的时间段的误差，也就是说大家都知道数据不正常是缓存的原因，大家都能接收，所以对于缓存的处理一般只要求达到最终一致性的需求。

