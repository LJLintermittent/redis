redis给缓存数据设置过期时间，因为内存是有限的，且根据缓存的业务需求，有些内容需要定时更换，比如用户的登录验证码，一般在几分钟内是可用的，通过过期时间来实现验证码的过期失效功能

redis内部是通过一个过期字典来保存数据的过期时间，过期字典的键指向redis数据库中的某个key，过期时间的值是一个long类型的整数，这个整数保存了key所指向的数据库键的过期时间，毫秒精度的unix时间戳

那么对过期键的删除其实就是先通过给定的key在过期字典里找，看存不存在，存在话将过期字典中的键（指向键空间的某个键）与它的所对应的值（过期时间戳）之间的关系进行一个解绑

过期键的判定通过过期字典，首先检查给定键是否存在于过期字典，如果存在，那么取得键的过期时间，检查当前unix时间戳是否大于键的过期时间，如果是的话，那么键已经过期，否则的话，键未过期。

过期数据的删除策略：

1.定时删除：在设置键的过期时间的同时设置一个定时器，就相当于一个过期回调函数，只要过期了，立马进行过期

2.惰性删除：只会在取出key的时候才对数据进行过期检查，这样对cpu最好，但是可能会存在太多过期的key没有删除

3.定期删除：每隔一段时间抽取一批key执行删除过期key的操作，且redis底层会通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响

可以看出仅仅通过惰性删除和定期删除是没有办法完全解决内存中存留部分过期key的情况，所以在极端情况下，还会有oom的风险

定时删除策略是对内存最友好的，通过使用定时器，定时删除策略会保证过期的键一定不会存在在数据库中，但是缺点也很明显，那就是对CPU不友好，思考这样一种情景，如果我的redis服务器的内存资源很充足，但是CPU比较紧张，那么如果这时候有大并发流量进来后，我希望CPU能更多的先去处理客户端发来的读写请求，而不是将有限的CPU资源用在删除过期key上。除此以外，很重要的一点是创建定时器需要用到redis的时间事件，而时间事件的实现方式是无序链表，查找某一个时间事件的时间复杂复杂度是0N，所以说明并不能高效处理大量的时间事件。

惰性删除是对CPU最友好的策略，程序只会在取出键时进行判断，如果key已经过期了，那么执行删除操作，但是缺点是对内存不友好，并且可能会造成不被访问的过期key永远不能被删除，思考场景：秒杀服务一般会将秒杀商品的信息提前缓存在redis中，并在秒杀活动过期以后的半个小时或者一个小时删除秒杀商品信息key，前端一般都不会再展示已经过期的秒杀商品了，那么这时候如果使用惰性删除策略，秒杀key永远不会再被用户访问，那么即使设置了过期时间，依然会永久存在redis中，这是一个非常严重的事情，也就是内存泄露

定期删除是为了平衡CPU与内存之间的开销。定期删除每隔一段时间执行一次删除过期的key的操作，并通过限制删除操作执行的时长和频率来控制对CPU的影响

目前的redis服务器实际会采用惰性删除+定期删除策略

### 惰性删除+定期删除原理：

首先对于惰性删除的源码，在expireIfNeeded方法

~~~c
int expireIfNeeded(redisDb *db, robj *key) {
    if (!keyIsExpired(db,key)) return 0;
    if (server.masterhost != NULL) return 1;
    if (checkClientPauseTimeoutAndReturnIfPaused()) return 1;
    /* Delete the key */
    if (server.lazyfree_lazy_expire) {
        dbAsyncDelete(db,key);
    } else {
        dbSyncDelete(db,key);
    }
    server.stat_expiredkeys++;
    propagateExpire(db,key,server.lazyfree_lazy_expire);
    notifyKeyspaceEvent(NOTIFY_EXPIRED,
        "expired",key,db->id);
    signalModifiedKey(NULL,db,key);
    return 1;
}
~~~

所有读写数据库的命令，在真正执行实际命令前，都会走一遍expireIfNeeded函数的流程，就相当于是一个过滤器一样，这时候如果检查键过期了需要对键进行删除操作，另外如果键不存会直接返回null

定期删除策略源码：activeExpireCycle

每当redis的服务器周期性操作serverCron函数（整个服务的调度函数）的时候，activeExpireCycle就会被调用，然后它会在规定的时间里，分多次遍历服务器中的各个数据库，从数据库中的过期字典里随机找出部分过期键，并执行删除

activeExpireCycle的工作模式可以总结如下：

~~~wiki
1.函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键
2.全局变量current_db会记录当前activeExpireCycle函数检查的进度，并在下一次调用的时候就需要从这个点出发继续寻找
3.随着serverCron函数的定时执行，activeExpireCycle函数不断被调用，最终会把所有库都扫描一遍，然后current_db重置为0，继续下一轮
~~~





redis内存淘汰策略：

1.volatile-lru（least recently used）：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰

2.volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰

3.volatile-random：从已设置过期时间的数据集中任意选择数据进行淘汰

4.volatile-lfu：从已设置过期时间的数据集中挑选最不经常使用的数据淘汰

5.allkeys-lru：当内存不足以写入新数据时，在键空间中，移除最近最少使用的key。这个是最常用的

6.allkeys-lfu：当内存不足以写入新数据时，在键空间中，移除最不经常使用的key

7.allkeys-random：从数据集中任意选择数据淘汰

8.no-eviction：禁止淘汰，当内存中不足以写入新数据的时候，直接报错

### 持久化机制

redis有两种持久化方式：一种是基于快照的，叫RDB，另一种是只追加文件，AOF

RDB：

redis可以通过创建快照的方式来获得存储在内存里面的数据在某个时间节点上的副本，redis创建快照后，可以对快照进行备份，可以将快照复制到其他服务器从而创建此redis服务器的副本，redis主从，还可以将redis留在原地以便重启服务器的时候使用

快照持久化是redis默认采用的持久化方式，在redis.conf配置文件中默认有如下配置：

save 900 1 ：在900s后有至少一个key发生变化，那么就需要触发bgsave命令创建快照

save 300 10 ：在300s后有至少10个key发生变化，那么就需要触发bgsave命令创建快照

save 60 10000：在60s后至少有10000个key发生变化，那么就需要触发bgsave命令创建快照

从快照这种方式可以 看出来，是存在丢失数据的风险的

主流的方式是AOF，aof持久化的实时性更好，因此已经成为更加主流的方式，appendonly yes开启AOF

开启AOF后每执行一条会更改redis的命令就会将这个命令加入到aof缓存中，然后再根据appendfsync的配置来决定何时将其同步到磁盘中的aof文件中，三种redis的aof同步策略是：

```
appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘
appendfsync no        #让操作系统决定何时进行同步
```

为了兼顾数据安全和写入性能，一般可以考虑appendfsync everysec参数，让redis每秒同步到磁盘一次aof，redis性能基本没有任何影响，而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据

redis4.0开始支持RDB和AOF的混合持久化方式，默认是关闭的，可以通过配置项 `aof-use-rdb-preamble` 开启

RDB+AOF：可以在同一个实例中组合 AOF 和 RDB。请注意，在这种情况下，当redis重启时，aof文件将用于重建原始数据集，因为他保证是最完整的

RDB的优势：

1.rdb是redis数据的非常紧凑的单文件时间节点表示，rdb文件非常适合备份，可以在灾难恢复时恢复不同版本的数据

2.rdb最大程度的提高了redis的性能，因为redis父进程为了持久化需要做的唯一工作时派生一个将完成其余所有工作的子进程，父进程永远不会执行磁盘IO或类似动作

3.与aof相比，rdb允许更快的启动大数据集

RDB的缺点：

1.如果需要在redis异常停止工作重启后最大限度的恢复数据，那么RDB并不好，虽然可以配置多个保存点，比如说x分钟至少有y个key发生了变化，但是通常这个时间会在几分钟以上，也就是说使用RDB需要做好损失数据的准备

2.RDB 经常需要 fork() 以便使用子进程在磁盘上持久化。如果数据集很大，Fork() 可能会很耗时，如果数据集很大且 CPU 性能不是很好，可能会导致 Redis 停止为客户端服务几毫秒甚至一秒钟。AOF 也需要 fork() 但你可以调整你想要重写日志的频率，而不会对持久性进行任何权衡

AOF的优势：

1.使用 AOF Redis 更持久：根本不做 fsync（交给操作系统），每秒 fsync，每次查询 fsync。使用 fsync 每秒写入性能的默认策略仍然很棒（fsync 是使用后台线程执行的，当没有 fsync 正在进行时，主线程将努力执行写入。）最多会丢失一秒的写数据

2.aof是仅附加日志，因此在断电时不会出现寻道或损坏的情况，即使日志由于某种原因（磁盘已满或者其他原因）以半写命令结束，redis-check-aof工具依然可以将它恢复

3.aof有易于理解和解析的格式包含所有操作的日志，可以轻松的导出AOF

AOF的缺点：

1.aof文件通常比相同数据集的等效RDB大

2.aof可能比rdb慢，具体取决于fsync策略，一般来说将fsync策略设置为每秒一次的时候性能是比较不错的，如果每次更新都fsync那么性能会下降很多

### 日志重写功能

随着更新操作的增多，aof会变得越来越大，比如我将一个值递增100次，最终在数据集中还是这一值，但是aof文件为了记录需要保存100个条目，为了重建状态可以直接使用一条命令达到最终的效果，所以redis加入了日志重写功能，能够在不中断对客户端的服务的连接的情况下在后台重建aof，bgrewriteaof命令可以重建aof，在mysql2.4版本已经能够自动触发日志重写

至于aof的刷盘策略，建议使用每秒一次的fsync。always策略足够安全但是非常慢，有组提交优化，如果有多个并行写入，redis会尝试执行单个fsync操作

aof断裂也是可以恢复数据的，比如正在写aof的过程中服务器宕机了，那么aof文件后面的部分命令可能会被截断，redis的最新版本无论如何都会加载aof，只需丢弃文件中最后一个格式不正确的命令就ok了

