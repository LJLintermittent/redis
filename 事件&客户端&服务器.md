## 事件

~~~wiki
redis客户端对服务端的每次调用，都会经历连接应答，发送请求，接收请求，关闭连接的步骤，其中在发送请求执行命令阶段，由于redis使用单线程来处理命令，所以每一条到达服务器的命令不会被立即执行，所有的命令都会进入到一个队列中，然后逐个执行，并且多个客户端发送的命令的执行顺序时不确定的，但是可以确定的是不会有两条命令同时被执行，不会产生并发问题，这就是6.0版本之前redis单线程的基本模型，其实到了6.0以后，也只是网络读写操作是多线程，执行命令仍然是单线程，不会有命令的线程安全问题

redis单线程模型为什么还这么快？
1.纯内存访问，所有键值对（键空间，是一个字典）放在内存中，内存的响应大约是100纳秒
2.非阻塞IO模型，redis在linux中采用epoll作为io多路复用技术的实现，再加上redis自身的事件处理模型将epoll中的连接，读写，关闭都转换为了事件，不在io上浪费过多事件
3.单线程执行命令，避免了线程的上下文切换以及线程不安全的命令的无锁化实现
4.官方解释redis的性能瓶颈在内存和网络，不在CPU，单线程容易维护，内部实现简单，不存在上下文切换，死锁，锁竞争等问题
~~~

redis服务器是一个事件驱动程序，服务器需要处理文件事件和定时事件两大类事件：
文件事件：redis服务器通过套接字与客户端，或者其他redis服务器进行连接，而文件事件就是服务器对套接字操作的抽象，服务器与客户端的通信会产生相应的文件事件，而服务器通过监听并处理这些事件来完成一系列网络通信操作

时间事件：redis服务器中的一些定时操作，比如servercron函数等，需要在给定的时间执行或者每隔一定的时间循环执行

### 文件事件

redis基于reactor模式开发了一套自己的AE事件模型，对于文件事件开发了自己的网络事件处理器：

文件事件采用io多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的文件事件处理器

当被监听的套接字准备好执行连接应答，读取，写入，关闭等操作时，与之相对应的文件事件就会产生。这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件

虽然文件事件处理器以单线程的方式运行（在redis6.0之前），但是通过io多路复用程序来同时监听多个套接字，文件事件处理器实现了高性能的网络通信模型，有很好的与redis服务器中其他的单线程模块进行对接，不会出现线程不安全的问题。同时保证了redis内部实现的简单性

### 文件事件处理器

文件事件处理器由四个部分组成：套接字，IO多路复用程序，文件事件分派器，事件处理器（命令请求处理器，命令回复处理器，连接应答处理等）

![image](https://cdn.jsdelivr.net/gh/chen-xing/figure_bed_02/cdn/20210907144216684.png)

文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答，写入，读取，关闭等操作时，就会产生对应的文件事件，因为服务器通常会连接大量的套接字，所以多个文件事件可能并发的出现

io多路复用程序负责监听多个套接字，并向文件事件分派器穿是那些产生了事件的套接字，这块需要注意，在io多路复用程序中，尽管文件事件有可能并发的产生，但是io多路复用程序总是会把产生事件的套接字都放到一个队列里面，然后通过这个队列，有序的同步的每次一个套接字的方式向文件事件分派器传送套接字，当上一个套接字产生的事件处理完成以后，也就是文件事件处理器对这个事件执行完毕，io多路复用程序里的队列才会继续向文件事件分派器发送下一个套接字

文件事件分派器接收来自io多路复用程序传来的套接字，并根据套接字产生的事件的类型，调用相对应的事件处理器，比如命令请求处理器等。

io多路复用：redis的io多路复用程序的所有功能都是通过包装select epoll kqueue evprot这些io多路复用函数库来实现的，io多路复用技术的使用让redis不需要额外的创建多余的线程来监听客户端的大量请求（类似于NIO中的selector组件）

事件的类型：

io多路复用程序可以监听多个套接字的AE_readable和AE_writable事件。

1.当套接字变得可读时，套接字会产生AE_readable事件

2.当套接字变得可写时，套接字会产生AE_writable事件

io多路复用程序允许服务器同时监听套接字的AE_readable和AE_writable事件，如果一个套接字同时产生了这两种事件，那么文件事件分派器会优先处理AE_readable事件，AE_readable事件处理完成以后才会处理AE_writable事件

也就是说一个套接字又可读又可写，那么先读后写

### 文件事件的处理器

redis为文件事件编写了多个文件事件处理器，这些事件处理器分别实现不同的网络通信需求

比如：
为了对连接服务器的客户端做一个应答， 那么服务器需要为监听套接字关联连接应答处理器

为了接收客户端发来的命令请求，服务器需要为套接字关联命令请求处理器

为了回复执行结果，关联了命令回复处理器

为了主从复制，主从服务器都关联了复制处理器等

1.连接应答处理器：

当redis服务器进行初始化时，程序会将这个连接应答处理器和服务器监听套接字的AE_readable事件关联起来，当有套接字通过connect连接服务器时，套接字就产生了AE_readable事件，将会引发连接应答处理器执行，并执行相应的套接字应答操作

2.命令请求处理器：

当一个客户端通过连接应答处理器成功连接到服务器以后，服务器将客户端套接字的AE_readable事件和命令请求处理器关联起来，当有客户端套接字向服务端发送请求命令的时候，套接字就会产生AE_readable的事件，从而引发命令请求处理器执行，并执行相应的套接字读取工作，在客户端连接服务器的整个过程中，服务器都会一直为客户端套接字的AE_readable事件关联命令请求处理器

3.当服务器有命令回复需要传送给客户端时，服务器会将客户端套接字的AE_writable事件与命令回复处理器关联起来，当客户端准备好接收服务器传回的回复时，就会产生AE_writable事件，从而引发命令回复处理器的执行，并执行相应的套接字写入操作

~~~wiki
一次完整的客户端与服务器连接事件示例：
假设一个服务器正在运行，那么这个服务器的监听套接字的AE_readable事件应该处于监听状态下，而该事件所对应的处理器应该是连接应答处理器。
如果这时候有一个redis客户端向服务器发起连接，那么监听套接字产生AE_readable事件，触发连接应答处理器执行，处理器会对客户端的连接请求进行应答，然后创建客户端套接字，以及客户端状态（redisclient），并将客户端套接字的AE_readable事件与命令请求处理器关联，使得客户端可以向主服务器发送请求命令
之后，假设客户端向主服务器发送一个命令请求，那么客户端套接字将产生AE_readable事件，从而引发命令处理器执行，处理器读取客户端的命令内容，然后传给相关程序去执行
执行命令将产生相应的命令回复，为了将这些命令回复回传给客户端，服务器会将客户端套接字的AE_writable事件与命令回复处理器关联，当客户端尝试读取回复的时候，客户端套接字将产生AE_writable事件，触发命令回复处理器执行，当命令回复处理器将回复内容全部写入到套接字之后，服务器就会解除客户端套接字AE_writable事件与命令回复处理器之前的关联
~~~

### 时间事件

redis中的时间事件分为两类：

1.定时事件，让一段程序在指定的时间之后执行一次。

2.周期性事件，让一段程序每隔指定的时间就执行一次

一个时间事件是由三个部分组成的，id，when，timeproc

id：服务器为此时间事件创建一个全局唯一id，id号按照从小到大的顺序递增，新的事件总是比前面的事件id大

when：毫秒精度的unix时间戳，记录了时间事件的到达时间

timeproc：时间事件处理器，其实就是一个函数，当时间事件到达后，服务器就会调用相关的处理器来处理时间

时间事件的实现：

服务器将所有时间事件都放到了一个无序链表中，每当时间事件执行器运行时，就遍历整个链表，查找已经到达的时间事件，并调用相应订单的事件处理器

注意，这里说保存时间事件的无序链表，不是因为id无序，而是when的到达时间不是从前到后。

其实正常模式下的redis服务器只使用一个serverCron时间事件，在benchmark模式下使用两个时间事件，所以无序链表不会影响性能

###  时间事件的应用实例

serverCron函数主要定期对自身资源和状态进行检查和调整，从而确保服务器可以长期，稳定的运行，这些定期操作由serverCron函数负责执行，它的主要工作包括：

1.更新数据库中的各类统计信息

2.清理数据库中的过期键值对

3.关闭和清理连接时效的客户端

4.aof和rdb的持久化

5.如果主从复制，那么主服务器要进行定期同步

6.如果集群，对集群进行定期同步和连接测试