## 事件

~~~wiki
redis客户端对服务端的每次调用，都会经历连接应答，发送请求，接收请求，关闭连接的步骤，其中在发送请求执行命令阶段，由于redis使用单线程来处理命令，所以每一条到达服务器的命令不会被立即执行，所有的命令都会进入到一个队列中，然后逐个执行，并且多个客户端发送的命令的执行顺序时不确定的，但是可以确定的是不会有两条命令同时被执行，不会产生并发问题，这就是6.0版本之前redis单线程的基本模型，其实到了6.0以后，也只是网络读写操作是多线程，执行命令仍然是单线程，不会有命令的线程安全问题

redis单线程模型为什么还这么快？
1.纯内存访问，所有键值对（键空间，是一个字典）放在内存中，内存的响应大约是100纳秒
2.非阻塞IO模型，redis在linux中采用epoll作为io多路复用技术的实现，再加上redis自身的事件处理模型将epoll中的连接，读写，关闭都转换为了事件，不在io上浪费过多事件
3.单线程执行命令，避免了线程的上下文切换以及线程不安全的命令的无锁化实现
4.官方解释redis的性能瓶颈在内存和网络，不在CPU，单线程容易维护，内部实现简单，不存在上下文切换，死锁，锁竞争等问题
~~~

redis服务器是一个事件驱动程序，服务器需要处理文件事件和定时事件两大类事件：
文件事件：redis服务器通过套接字与客户端，或者其他redis服务器进行连接，而文件事件就是服务器对套接字操作的抽象，服务器与客户端的通信会产生相应的文件事件，而服务器通过监听并处理这些事件来完成一系列网络通信操作

时间事件：redis服务器中的一些定时操作，比如servercron函数等，需要在给定的时间执行或者每隔一定的时间循环执行

### 文件事件

redis基于reactor模式开发了一套自己的AE事件模型，对于文件事件开发了自己的网络事件处理器：

文件事件采用io多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的文件事件处理器

当被监听的套接字准备好执行连接应答，读取，写入，关闭等操作时，与之相对应的文件事件就会产生。这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件

虽然文件事件处理器以单线程的方式运行（在redis6.0之前），但是通过io多路复用程序来同时监听多个套接字，文件事件处理器实现了高性能的网络通信模型，有很好的与redis服务器中其他的单线程模块进行对接，不会出现线程不安全的问题。同时保证了redis内部实现的简单性

### 文件事件处理器

文件事件处理器由四个部分组成：套接字，IO多路复用程序，文件事件分派器，事件处理器（命令请求处理器，命令回复处理器，连接应答处理等）

![image](https://cdn.jsdelivr.net/gh/chen-xing/figure_bed_02/cdn/20210907144216684.png)

文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答，写入，读取，关闭等操作时，就会产生对应的文件事件，因为服务器通常会连接大量的套接字，所以多个文件事件可能并发的出现

io多路复用程序负责监听多个套接字，并向文件事件分派器穿是那些产生了事件的套接字，这块需要注意，在io多路复用程序中，尽管文件事件有可能并发的产生，但是io多路复用程序总是会把产生事件的套接字都放到一个队列里面，然后通过这个队列，有序的同步的每次一个套接字的方式向文件事件分派器传送套接字，当上一个套接字产生的事件处理完成以后，也就是文件事件处理器对这个事件执行完毕，io多路复用程序里的队列才会继续向文件事件分派器发送下一个套接字

文件事件分派器接收来自io多路复用程序传来的套接字，并根据套接字产生的事件的类型，调用相对应的事件处理器，比如命令请求处理器等。

io多路复用：redis的io多路复用程序的所有功能都是通过包装select epoll kqueue evprot这些io多路复用函数库来实现的，io多路复用技术的使用让redis不需要额外的创建多余的线程来监听客户端的大量请求（类似于NIO中的selector组件）

事件的类型：

io多路复用程序可以监听多个套接字的AE_readable和AE_writable事件。

1.当套接字变得可读时，套接字会产生AE_readable事件

2.当套接字变得可写时，套接字会产生AE_writable事件

io多路复用程序允许服务器同时监听套接字的AE_readable和AE_writable事件，如果一个套接字同时产生了这两种事件，那么文件事件分派器会优先处理AE_readable事件，AE_readable事件处理完成以后才会处理AE_writable事件

也就是说一个套接字又可读又可写，那么先读后写

### 文件事件的处理器

redis为文件事件编写了多个文件事件处理器，这些事件处理器分别实现不同的网络通信需求

比如：
为了对连接服务器的客户端做一个应答， 那么服务器需要为监听套接字关联连接应答处理器

为了接收客户端发来的命令请求，服务器需要为套接字关联命令请求处理器

为了回复执行结果，关联了命令回复处理器

为了主从复制，主从服务器都关联了复制处理器等

1.连接应答处理器：

当redis服务器进行初始化时，程序会将这个连接应答处理器和服务器监听套接字的AE_readable事件关联起来，当有套接字通过connect连接服务器时，套接字就产生了AE_readable事件，将会引发连接应答处理器执行，并执行相应的套接字应答操作

2.命令请求处理器：

当一个客户端通过连接应答处理器成功连接到服务器以后，服务器将客户端套接字的AE_readable事件和命令请求处理器关联起来，当有客户端套接字向服务端发送请求命令的时候，套接字就会产生AE_readable的事件，从而引发命令请求处理器执行，并执行相应的套接字读取工作，在客户端连接服务器的整个过程中，服务器都会一直为客户端套接字的AE_readable事件关联命令请求处理器

3.当服务器有命令回复需要传送给客户端时，服务器会将客户端套接字的AE_writable事件与命令回复处理器关联起来，当客户端准备好接收服务器传回的回复时，就会产生AE_writable事件，从而引发命令回复处理器的执行，并执行相应的套接字写入操作

~~~wiki
一次完整的客户端与服务器连接事件示例：
假设一个服务器正在运行，那么这个服务器的监听套接字的AE_readable事件应该处于监听状态下，而该事件所对应的处理器应该是连接应答处理器。
如果这时候有一个redis客户端向服务器发起连接，那么监听套接字产生AE_readable事件，触发连接应答处理器执行，处理器会对客户端的连接请求进行应答，然后创建客户端套接字，以及客户端状态（redisclient），并将客户端套接字的AE_readable事件与命令请求处理器关联，使得客户端可以向主服务器发送请求命令
之后，假设客户端向主服务器发送一个命令请求，那么客户端套接字将产生AE_readable事件，从而引发命令处理器执行，处理器读取客户端的命令内容，然后传给相关程序去执行
执行命令将产生相应的命令回复，为了将这些命令回复回传给客户端，服务器会将客户端套接字的AE_writable事件与命令回复处理器关联，当客户端尝试读取回复的时候，客户端套接字将产生AE_writable事件，触发命令回复处理器执行，当命令回复处理器将回复内容全部写入到套接字之后，服务器就会解除客户端套接字AE_writable事件与命令回复处理器之前的关联
~~~

### 时间事件

redis中的时间事件分为两类：

1.定时事件，让一段程序在指定的时间之后执行一次。

2.周期性事件，让一段程序每隔指定的时间就执行一次

一个时间事件是由三个部分组成的，id，when，timeproc

id：服务器为此时间事件创建一个全局唯一id，id号按照从小到大的顺序递增，新的事件总是比前面的事件id大

when：毫秒精度的unix时间戳，记录了时间事件的到达时间

timeproc：时间事件处理器，其实就是一个函数，当时间事件到达后，服务器就会调用相关的处理器来处理时间

时间事件的实现：

服务器将所有时间事件都放到了一个无序链表中，每当时间事件执行器运行时，就遍历整个链表，查找已经到达的时间事件，并调用相应订单的事件处理器

注意，这里说保存时间事件的无序链表，不是因为id无序，而是when的到达时间不是从前到后。

其实正常模式下的redis服务器只使用一个serverCron时间事件，在benchmark模式下使用两个时间事件，所以无序链表不会影响性能

###  时间事件的应用实例

serverCron函数主要定期对自身资源和状态进行检查和调整，从而确保服务器可以长期，稳定的运行，这些定期操作由serverCron函数负责执行，它的主要工作包括：

1.更新数据库中的各类统计信息

2.清理数据库中的过期键值对

3.关闭和清理连接时效的客户端

4.aof和rdb的持久化

5.如果主从复制，那么主服务器要进行定期同步

6.如果集群，对集群进行定期同步和连接测试

### 补充redis6中的多线程问题

redis6之前的版本，在处理客户端请求时，包括获取（socket读），解析，执行，内容返回（socket写）等操作都是一个顺序串行的主线程处理，这就是所谓的单线程，但是严格来讲redis4.0以后，除了主线程以外，还有一些后台线程在处理一些较为缓慢的操作，例如脏数据的清理，无用连接的释放，大key删除等。

对于redis6.0之前在网络读写这块使用单线程的解释，官方说明是使用redis时，几乎不存在cpu称为瓶颈的情况，redis主要受限于网络和内存，使用单线程后，可维护性高，多线程模型虽然在某些方面表现优异，但是却引入了线程执行顺序的不确定性，容易带来并发读写的一系列问题，redis通过ae事件模型以及io多路复用机制，处理性能非常快，没有必要使用单线程，像hash键的底层如果是字典也就是hashtable编码的话，他存在渐进式rehash的过程，以及lpush等线程不安全的命令，而redis采用单线程设计可以使用无锁化实现这些命令

至于为什么redis6.0以后使用多线程，我认为完全是一个历史发展的问题，一切软件都不能脱离硬件的发展，目前多核cpu越来越普遍，并且商业项目所需要的qps越来越高，在以前可能cpu确实不会成为redis的瓶颈，但是随着时间的推移，redis必须跟进发展，采用多线程的方式充分利用cpu的内核，来分担主线程的网络io压力。需要注意的是，redis6.0的多线程部分只是用来处理网络数据的读写和协议解析，真正执行命令还是单线程，所以以前网络读写+执行命令整体单线程的时候使用的无锁化线程不安全的命令，到了6.0以后依然没变，可以正常使用

![image](https://cdn.jsdelivr.net/gh/chen-xing/figure_bed_02/cdn/20210907165714881.png)

redis6.0多线程执行流程：

1.主线程负责接收建立连接请求，获取socket放入全局等待处理队列

2.主线程处理完读事件后，通过RR（round robin）将这些连接分配给io线程组（多线程）

3.主线程阻塞等待io线程组（多线程）读取socket完毕

4.主线程是以单线程的方式执行请求命令，请求数据读取并解析完毕，但并不执行

5.主线程阻塞等待io线程组将数据回写socket完毕

6.接触绑定，清空队列

![iamge](https://cdn.jsdelivr.net/gh/chen-xing/figure_bed_02/cdn/20210907170554244.png)

这种多线程的设计特点：
1.io线程要么同时读socket，要么同时写，不会同时读写

2.io线程只负责读写socket解析命令，不负责命令执行

总结一下：

redis主线程处理客户端连接操作

redis的io线程组，这里也就是多线程，来负责客户端的读写操作

redis的io线程处理时，redis主线程处理部分连接完毕后需要等待io线程处理客户端读写操作完毕

redis的多线程模型可以改进：

1.一个线程接收请求

2.io多线程负责处理读写操作

3.操作线程负责单线程执行命令

4.不同的redisdb拥有自己的操作线程

redis主线程一次性获取最大为1000个客户端连接（MAX_ACCEPTS_PER_CALL：这个参数用来限制一次接收的客户端连接），将其放到read pending队列，在下一次aemain主循环中调用beforesleep函数，该函数将read pending队列与write pending队列中的客户端socket散列到io线程中执行读写操作，并且自身负责下标为0处的客户端，然后等待io线程完毕后主线程继续执行。同时真正执行命令还是由单线程执行。

所以Redis的多线程仅仅是减少了io的时间，另外官方也说了，到目前位置，redis的性能瓶颈还是内存和网络，既然在6.0用多线程解决了网络部分的问题，那么剩下的想提升性能，最好的方式是用redis集群的方式，而不是再思考怎么让get，set命令能多线程执行。

### 客户端重点总结

服务器状态结构使用clients链表连接起多个客户端状态，新添加的客户端状态会被到链表的末尾

客户端状态的flag属性使用不同标志来表示客户端的角色，以及客户端当前所处的状态

输入缓冲区记录了客户端发送的命令请求，这个缓冲区的大小不能超过1GB

命令的参数和参数个数会被记录在客户端状态的argv和argc属性中，而cmd属性则记录了客户端要执行命令的实现函数

客户端有固定大小缓冲区和可变大小缓冲区两种可用，其中固定大小缓冲区的最大大小为16K，而可变大小缓冲区的最大大小不能超过服务器设置的硬性限制值

输出缓冲区限制值有两种，如果输出缓冲区的大小超过了服务器设置的硬性限制，那么客户端会被立即关闭，除此之外，如果客户端在一定时间内，一直超过服务器设置的软性限制，那么客户端也会被关闭

当一个客户端通过网络连上服务器后。服务器会为这个客户端创建相应的客户端状态。网络连接关闭，发送了不符合协议格式的命令请求，成为client kill命令的目标，空转时间超时，输出缓冲区的大小超出限制，以上这些原因都会造成客户端的关闭

处理lua脚本的伪客户端在服务器初始化时创建，这个客户端会一直存在，直到服务器关闭

载入aof文件时使用的伪客户端在载入工作开始时动态创建，载入工作完毕后关闭

### 服务端重点总结

一个命令请求从发送到完成包括以下步骤：

1.客户端将命令发送给服务器

2.服务器读取命令请求，并分析出命令参数

3.命令执行器根据参数查找命令的实现函数

4.服务器将命令回复给客户端

serverCron函数默认100毫秒执行一次，它的主要工作就是更新服务器状态信息，处理服务器接收的sigterm信号，管理客户端资源和数据库状态，检查并执行持久化操作等

服务端从启动到能够处理客户端命令请求需要执行以下步骤：

1.初始化服务器状态

2.载入服务器配置

3.初始化服务器数据结构

4.还原数据库状态

5.执行事件

