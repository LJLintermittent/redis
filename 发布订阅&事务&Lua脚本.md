~~~wiki
发布与订阅部分总结：
在服务器状态的pubsub_channels字典里保存了所有频道的订阅关系，subscribe命令负责将客户端与被订阅的频道关联到这个字典里面，而unsubscribe命令则负责接触客户端和被退订频道之间的关系
在服务器状态的pubsub_patterns链表中保存了所有模式的订阅关系，psubscribe命令负责将客户端和被订阅的模式记录到这个链表中。而punsubscribe命令负责接触客户端与被退订模式之间的关系
publish命令通过访问pubsub_channels字典来向频道的所有订阅者发布消息，通过访问pubsub_patterns来向所有匹配频道的模式的订阅者发送消息
pubsub命令的三个子命令都是通过读取pubsub_channels字典和pubsub_patterns链表中的信息来实现的
~~~

### 事务

redis通过mutil，watch，exec命令来实现事务功能，事务提供了一种将多个请求打包，然后一次性，按顺序执行完成的特性，并且在事务执行期间，服务器不会中断事务而去执行其他客户端的命令请求，它会将事务中的所有命令执行完毕，然后才去处理其他客户端的命令请求。

redis的事务总是从mutil命令开始，接着将多个命令放入事务中，最后由exec命令将这个事务提交给服务器执行

#### 事务开始

mutil命令标志着redis事务的开始，mutil命令可以将执行命令的客户端从非事务状态切换到事务状态，这个切换操作是通过在redisclient结构中的flags属性打开redis_mutil标志来实现的，mutil命令实现就可以理解为打开客户端状态的事务标识

命令入队：

当一个客户端处于非事务状态时，它的命令总会被立即执行

与之不同的是当一个客户端是事务状态，那么服务器会根据命令的不同来决定是否立即执行

1.如果客户端发送的命令为exec，discard，watch，mutil等命令时，处于事务状态的客户端也会立即执行这些命令，与此对应的，如果是这四个命令之外的其他命令，那么服务器不会立即执行，而是将这个命令放入一个事务队列里面，然后向客户端返回一个queued回复

在事务状态下，服务器要通过判断命令来选择是否立即执行

#### 事务队列

每个redis的客户端都有一个自己的事务状态，这个事务状态保存在redisclient的mutilstate（mstate）属性中

事务状态里面又包含了一个队列，以及一个已入对命令的计数器

~~~c
typedef struct mutilState{
	mutilcmd //事务队列，FIFO
    count //已入队命令计数    
}
~~~

事务队列是一个mutilcmd类型的数组，也就是说这个队列是用数组实现的，数组中的每个mutilcmd结构都保存了已经入队命令的相关信息，包括指向命令实现函数的指针，命令的参数，参数的数量

~~~c
typedef struct mutilcmd{
    robj  argv //参数
    int   argc //参数数量
    struct redisCommand //指向命令实现函数的指针
}
~~~

事务队列先进先出，较先入队的命令会被放在数组的前面。

#### 执行事务

当一个处于事务状态下的客户端向服务器发送exec命令时，这个exec命令将立即被服务器执行，服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行结果一次性返回

#### watch命令

watch命令是一个乐观锁,它可以在exec命令执行前或者直接在事务开启前(mutil)监视任意数量的数据库键,并在exec命令执行的时候如果发现在这个事务内的某个键被其他客户端修改了,那么服务器将拒绝执行这个事务,返回空回复.

watch的实现原理:

每个redis数据库都保存着一个watched_keys字典，这个字典的键是某个被watch监视的数据库键，值是一个链表，链表中每一个节点代表了一个监视这个数据库键的客户端，所以对于每一个被监视的key，这个字典会记录有哪些客户端监视正在监视它

监视机制的触发：

所有对数据库有更改的操作，比如set，sadd，lpush等，在执行的时候都会调用一个函数touchwatchkey，这个函数对这个watched_keys进行检查，查看是否有客户端对刚刚被修改的这个key进行了监视，如果有的话那么touchwatchkey会将被修改键的它所被监视的客户端的redis_dirty_cas标致打开，表示这个客户端的事务安全性被破坏，并且已经检测到了。

#### 判断事务是否安全

当客户端执行exec的时候，服务器会根据这个客户端的redis_dirty_cas标致来决定是否执行事务，如果这个标致被打开了，证明这个客户端监视的key在事务中被其他的客户端修改过，那么表明当前客户端这个事务是不安全的，所以服务器拒绝执行客户端提交的事务

如果redis_dirty_cas标致没有被打开，那么说明客户端监视的所有key都没有被修改过，或者这个客户端没有监视key，事务就是安全的，服务器会执行这个客户端提交的命令

~~~wiki
一个完整的watch执行的流程：
当在开始事务之前，一个客户端执行了watch，来监视某一个key或一些key，然后这个监视信息就会被加入到watched_keys字典中，键是被监视的数据库键，值是一个链表，因为可能有很多客户端监视这个key，所以值是所有监视这个key的客户端，接下来客户端发送mutil命令，然后正常输入命令，这时有另外一个客户端也来操作这个key，造成第一个客户端的key在事务中被修改，在第二个客户端中由于调用了修改命令，那么在这之前会先触发touchwatchkey函数，这个函数来检测这个key是否有客户端监视着，如果监视着，那么第二个客户端的命令依然会执行，但是它会修改所有监视这个key的客户端状态中的redis_dirty_cas标志，把这个标志打开，那么在第一个客户端在执行exec命令的时候，如果发现标志已经打开了，那么服务器拒绝执行这个客户端提交的事务
~~~

#### redis事务的ACID特性

事务具有原子性，数据库将事务中的多个操作当做一个操作来执行，要么都执行，要么都不执行，redis跟关系型数据库实现的事务有个很大的不同时redis的事务没法回滚，所以他不像关系型数据库那样定义原子性，关系型数据库的原子性可以在要么都执行，要么都不执行的基础上加一句要么都成功，要么都失败，而redis确实会保证操作都执行了，但是可能会有命令失败，比如在mutil开启一个事务后，我们写入了一条RPUSH命令来操作字符串键，错误地使用列表键的命令来操作字符串键，但是在执行期间事务后续命令依然会执行下去，并且之后的命令不会有所影响

redis作者的解释是对于redis如果加上了回滚机制，与redis简单高效的设计理念不符，并且redis的事务如果中途有命令出错，通常都是编程出错，应该在测试环境就解决掉，所以他认为redis没有必要加回滚机制

一致性指的是如果数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功， 也应该是一致的，这里的一致指的是数据符合数据库本身的定义和要求，没有包含非法或者无效的错误数据

redis通过谨慎的错误检测和简单的设计来保证事务的一致性，比如在以下三个错误方向，redis都做了相应的解决

1.入队错误

入队错误，如果一个事务在入队命令的过程中，出现了命令不存在，命令格式不正确等，那么redis会帮你检查出来，因为它要保证一致性，而像那种对字符串键使用一个列表键命令，redis在这个阶段检查不出来，所以事务可以正常执行，只不过中间有命令是错的，但是还不影响其他事务，并且没有回滚机制。

这是入队错误的情况，redis不会尝试执行在入队阶段就有错误的命令

2.执行错误

执行过程中发生的错误都是一些不能在入队时被服务器发现的错误，这些错误只会在命令实际执行时被发现

即使在事务的执行过程中发现了错误，服务器也不会中断事务的执行，它会继续执行事务中剩下的命令，并且已经执行的命令不会被出错的命令所影响

最常见的错误就是对key执行了错误类型的操作

因为在事务执行过程中，出错的命令会被服务器识别出来，并进行相应的错误处理，所以这些出错的命令不会对数据库有任何修改，所以不会对事务的一致性产生影响。但是就是不能回滚，这种错误就需要在测试环境中找出来改掉

3.服务器停机

如果redis服务器在执行事务的过程中停机了，那么根据服务器所使用的的持久化方式，可能会出现以下情况：

如果运行在无持久化的模式下，纯内存模式，那么重启后数据库是空白的，因此数据总是一致的

如果在rdb下，rdb会恢复，来将其还原到一个一致性状态，如果找不到相应的rdb，那么数据库空白，空白数据库总是一致的

如果在aof下，aof会恢复到一个一致状态，如果找不到aof，数据库空白，总是一致

隔离性指的是数据库中并发的多个事务在执行，各个事务之间不会互相影响，并且在并发状态下执行的事务与串行化执行的效果一样

因为redis使用单线程来做命令的执行，这一点到redsi6.0依然是这样，并且服务器保证在执行事务期间不会对事务进行中断，因此redis事务总是串行化运行，自然能保证隔离性

持久性：当一个事务执行完毕后，执行这个事务所得到的结果已经保存到了永久性介质中，即使服务器在执行完事务以后停机了，执行完事务所得的结果也不会丢失

因为redis的事务不过是简单的用一个队列包裹了一组命令，redis并没有为事务提供额外的持久化功能，所以事务的持久性取决于redis所用的持久化模式

当redis运行在无持久化模式下，那么不具备持久性

当在rdb模式下，服务器只会在特定的保存条件满足后才会执行bgsave，对数据库进行保存操作，并且异步执行的bgsave不能保证事务数据会在第一时间保存在磁盘中，所以rdb不能保证事务的持久性

如果服务器运行在aof下，并且appendfsync选项的值为always时，那么程序总会在执行命令后调用同步函数fsync，所以这种是持久的

但是在no 和 every模式下是不能保证事务持久性的

另外如果一定保证事务的持久性，也可以在事务提交前，也就是exec前，调用save命令，这种方式一定是持久的，不过效率太低，不具有实用性