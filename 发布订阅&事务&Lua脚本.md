~~~wiki
发布与订阅部分总结：
在服务器状态的pubsub_channels字典里保存了所有频道的订阅关系，subscribe命令负责将客户端与被订阅的频道关联到这个字典里面，而unsubscribe命令则负责接触客户端和被退订频道之间的关系
在服务器状态的pubsub_patterns链表中保存了所有模式的订阅关系，psubscribe命令负责将客户端和被订阅的模式记录到这个链表中。而punsubscribe命令负责接触客户端与被退订模式之间的关系
publish命令通过访问pubsub_channels字典来向频道的所有订阅者发布消息，通过访问pubsub_patterns来向所有匹配频道的模式的订阅者发送消息
pubsub命令的三个子命令都是通过读取pubsub_channels字典和pubsub_patterns链表中的信息来实现的
~~~

### 事务

redis通过mutil，watch，exec命令来实现事务功能，事务提供了一种将多个请求打包，然后一次性，按顺序执行完成的特性，并且在事务执行期间，服务器不会中断事务而去执行其他客户端的命令请求，它会将事务中的所有命令执行完毕，然后才去处理其他客户端的命令请求。

redis的事务总是从mutil命令开始，接着将多个命令放入事务中，最后由exec命令将这个事务提交给服务器执行

#### 事务开始

mutil命令标志着redis事务的开始，mutil命令可以将执行命令的客户端从非事务状态切换到事务状态，这个切换操作是通过在redisclient结构中的flags属性打开redis_mutil标志来实现的，mutil命令实现就可以理解为打开客户端状态的事务标识

命令入队：

当一个客户端处于非事务状态时，它的命令总会被立即执行

与之不同的是当一个客户端是事务状态，那么服务器会根据命令的不同来决定是否立即执行

1.如果客户端发送的命令为exec，discard，watch，mutil等命令时，处于事务状态的客户端也会立即执行这些命令，与此对应的，如果是这四个命令之外的其他命令，那么服务器不会立即执行，而是将这个命令放入一个事务队列里面，然后向客户端返回一个queued回复

在事务状态下，服务器要通过判断命令来选择是否立即执行

#### 事务队列

每个redis的客户端都有一个自己的事务状态，这个事务状态保存在redisclient的mutilstate（mstate）属性中

事务状态里面又包含了一个队列，以及一个已入对命令的计数器

~~~c
typedef struct mutilState{
	mutilcmd //事务队列，FIFO
    count //已入队命令计数    
}
~~~

事务队列是一个mutilcmd类型的数组，也就是说这个队列是用数组实现的，数组中的每个mutilcmd结构都保存了已经入队命令的相关信息，包括指向命令实现函数的指针，命令的参数，参数的数量

~~~c
typedef struct mutilcmd{
    robj  argv //参数
    int   argc //参数数量
    struct redisCommand //指向命令实现函数的指针
}
~~~

事务队列先进先出，较先入队的命令会被放在数组的前面。

#### 执行事务

当一个处于事务状态下的客户端向服务器发送exec命令时，这个exec命令将立即被服务器执行，服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行结果一次性返回

#### watch命令

watch命令是一个乐观锁,它可以在exec命令执行前或者直接在事务开启前(mutil)监视任意数量的数据库键,并在exec命令执行的时候如果发现在这个事务内的某个键被其他客户端修改了,那么服务器将拒绝执行这个事务,返回空回复.

watch的实现原理:

每个redis数据库都保存着一个watched_keys字典，这个字典的键是某个被watch监视的数据库键，值是一个链表，链表中每一个节点代表了一个监视这个数据库键的客户端，所以对于每一个被监视的key，这个字典会记录有哪些客户端监视正在监视它

监视机制的触发：

所有对数据库有更改的操作，比如set，sadd，lpush等，在执行的时候都会调用一个函数touchwatchkey，这个函数对这个watched_keys进行检查，查看是否有客户端对刚刚被修改的这个key进行了监视，如果有的话那么touchwatchkey会将被修改键的它所被监视的客户端的redis_dirty_cas标致打开，表示这个客户端的事务安全性被破坏，并且已经检测到了。

#### 判断事务是否安全

当客户端执行exec的时候，服务器会根据这个客户端的redis_dirty_cas标致来决定是否执行事务，如果这个标致被打开了，证明这个客户端监视的key在事务中被其他的客户端修改过，那么表明当前客户端这个事务是不安全的，所以服务器拒绝执行客户端提交的事务

如果redis_dirty_cas标致没有被打开，那么说明客户端监视的所有key都没有被修改过，或者这个客户端没有监视key，事务就是安全的，服务器会执行这个客户端提交的命令