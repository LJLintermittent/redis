# 《Redis设计与实现--阅读笔记》

### 简单动态字符串

Redis在字符串这个数据结构上没有使用C语言提供的原生字符串，而是自己定义了一种结构体，在源码中的sds.h文件中定义，它除了底层用一个char型数据buf来存储字符以外，还维护了一个int的len属性，表示buf数组已经占用的空间大小，即字符串长度，还有一个int类型的free属性，它表示数据中还未分配的空间大小，正是由于这两个额外的属性，赋予了redis中的字符串强于C语言字符串的性能与能力。

主要性能优秀的地方体现在：

1.常数复杂度获取字符串的长度：由于内部维护了一个len属性，那么就可以直接通过len属性来获取字符串的长度，而不用像C一样要遍历字符串的每一个字符，直到遇到一个空字符结尾，才能统计出字符串的长度。将时间复杂度从O(n)缩小到了O(1)

2.杜绝了缓冲区的溢出：如果对字符串进行拼接操作，原生C字符串来拼接的时候，strcat会假设用户已经分配了足够的内存空间，一旦没有，就会发生缓冲区溢出，假设有两个相邻内存空间的C字符串，如果对第一个进行拼接操作，没有分配空间的话，那么S1的数据将会溢出到S2，造成S2的内容被修改。而SDS的API在进行修改的时候会判断内存空间是否满足需求。

3.由于free属性的存在，在字符串拼接或者截断操作时，不需要每次都进行内存空间的重分配，SDS在拼接完成以后，会将当前的数组长度len赋给free，表示拼接完成后数组还有len长度的空闲空间，当下次再拼接的时候，如果字符串长度小于free，那么不需要内存重分配了，如果大于free，那么再进行重分配。重分配的策略如下：如果对SDS进行修改后,SDS的长度，也就是len属性，小于1MB，那么程序分配和len相同的未使用空间，这时SDS的free和len相等。如果对SDS的修改后长度大于1MB，那么程序会分配1MB的未使用空间，比如，len属性为30MB，那么free为1MB。通过空间预分配策略，redis可以减少连续执行字符串拼接操作所需的内存重分配次数。

惰性空间释放：SDS截断操作后，redis不会释放空闲空间，而是作为free属性依然不变，下次再拼接时，不需要内存重分配，当然，如果确实要释放空间，也有相应的API操作来真正释放不需要的空间。

4.二进制安全，由于可以保存空字符在字符串中，而不像C只能放在结尾做标识，所以可以保存二进制文件，因为SDS使用len属性来判断是不是空字符串，而不是靠空字符。

### 链表

链表提供了高效的节点重排能力，以及顺序性的节点访问方式。并且可以通过增删节点来灵活地调整链表的长度。对于Redis中列表键的底层实现就是链表。除了链表键之外，发布与订阅，慢查询，监视器等功能也用到了链表。每个链表节点的定义在adlist.h/listNode结构体中定义，它定义了前置节点，后置节点，和节点值，也就意味着多个链表节点可以通过前后指针来形成双向链表。虽然可以直接使用listNode组成链表，但是redis还提供了一种结构体，adlist.h/list来持有链表，操作起来会更方便，因为这个结构体里面定义了更多的信息，比如表头结点，表尾结点，链表所包含的节点的数量，以及三个函数，节点值复制函数，节点值释放函数，节点值对比函数

综上所述：链表的实现可以总结如下：
1.双端，链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的时间复杂度为O(1)。

2.无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问是以NULL结尾，不会形成环形链表

3.带有头指针和表尾指针，通过list结构的head指针和tail指针，程序获取头尾指针的时间复杂度为O(1)

4.带有链表长度计数器，可以直接通过len属性获取链表的长度。

5.多态：链表节点使用指针来保存节点值，可以通过list结构体中的dup，free，match三个属性为节点值设置类型特定函数，所以链表可以用于保存不同类型的值

### 字典

Redis的字典所使用的哈希表由dict/dictht结构体定义：

有四个属性：分别是哈希表数组，哈希表大小，哈希表大小掩码(它总是等于size-1,用来计算哈希桶的索引位置)以及还有一个used属性，用来记录哈希表中已有的节点数量

table属性是一个数组，他里面的每一个元素都是一个指向dict.h/dictEntry的指针，每个dictEntry结构中保存着一个键值对。

哈希表节点：dict.h/dictEntry:每个dictEntry结构中保存着一个键值对，key属性保存着键值对中的键，value属性则保存着键值对中的值，其中键值对中的值既可以是一个指针，又可以是一个整数，next属性是指向另一个哈希表节点的指针，由此可见redis的哈希表也是使用链地址法解决哈希冲突问题的

字典：dict.h/dict 结构表示，在这个结构体中定义了类型特定函数，私有数据，两个哈希表，rehashindex。ht属性是一个包含两项的数组，字典一般使用ht[0]，ht[1]一般用作rehash的时候使用，除了ht[1]外，另一个与rehash有关的属性就是rehashindex，它记录rehash目前的进度，如果目前没有正在进行的rehash，那么它的值为-1；

哈希算法：hash = hashFunction()计算出来key的哈希值，然后将这个hash值&ht[0]中的sizemask，也就是hash值&size-1，从而计算除了索引值。

解决键冲突：当有两个或两个以上的键被分配到了同一个索引上时，我们就称这些键发生了冲突。redis的哈希表使用链地址法来解决哈希冲突问题，因为每个哈希表节点entry他都有一个next属性，那么多个在同一索引下的哈希表节点就可以通过next指针来连接到一起形成一个单链表从而解决冲突问题。而且为了速度考虑，没个发生冲突的节点进来后总是插入的链表的最前面，也就是头插法。

rehash：随机操作的不断执行，哈希表的节点会不断的增加或减少，为了让哈希表的负载因子维持在一个合理的范围内，当哈希表中保存的键值对数量过多或过少时应该对大小进行相应的扩展和压缩，扩展和压缩的操作通过rehash操作来完成。

1.为字典ht[1]分配内存空间，这个哈希表的大小取决于要执行的操作，以及ht[0]当前包含的键值对的数量，这个数量可以直接由used属性来获取，如果执行的是扩展操作，那么ht[1]的大小为大于等于ht[0]的used属性值*2的2的n次方，如果执行的是收缩操作，那么备用哈希表的大小为第一个大于等于已用节点的2的n次方(也就是不需要×2)。

2.将保存在ht[0]中的所有键值对rehash到备用表上面，rehash指的就是重新计算索引值和哈希值，然后将键值放置到备用表的指定位置上。

3.当ht[0]上的所有数据都迁移到了ht[1]时，ht[0]变为了空表，释放ht[0]，将ht[1]重新设置为ht[0]，并创建一个新的ht[1]作为空哈希表，为下一次rehash做好准备。

至此哈希表的rehash过程就到此结束。负载因子的计算公式为load_factor = used / size，并且当哈希表的负载因子小于0.1时，redis会自动对哈希表执行收缩操作

渐进式rehash，rehash操作不是一次性完成的。而是分多次，渐进式地完成的，原因在于当哈希表中的哈希键数量过多时，如果一次性全移到备用表，可能会导致服务器在一段时间内停止提供服务。

渐进式rehash步骤：

1.

