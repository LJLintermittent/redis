# 《Redis设计与实现--阅读笔记》

### 简单动态字符串

Redis在字符串这个数据结构上没有使用C语言提供的原生字符串，而是自己定义了一种结构体，在源码中的sds.h文件中定义，它除了底层用一个char型数据buf来存储字符以外，还维护了一个int的len属性，表示buf数组已经占用的空间大小，即字符串长度，还有一个int类型的free属性，它表示数据中还未分配的空间大小，正是由于这两个额外的属性，赋予了redis中的字符串强于C语言字符串的性能与能力。

主要性能优秀的地方体现在：

1.常数复杂度获取字符串的长度：由于内部维护了一个len属性，那么就可以直接通过len属性来获取字符串的长度，而不用像C一样要遍历字符串的每一个字符，直到遇到一个空字符结尾，才能统计出字符串的长度。将时间复杂度从O(n)缩小到了O(1)

2.杜绝了缓冲区的溢出：如果对字符串进行拼接操作，原生C字符串来拼接的时候，strcat会假设用户已经分配了足够的内存空间，一旦没有，就会发生缓冲区溢出，假设有两个相邻内存空间的C字符串，如果对第一个进行拼接操作，没有分配空间的话，那么S1的数据将会溢出到S2，造成S2的内容被修改。而SDS的API在进行修改的时候会判断内存空间是否满足需求。

3.由于free属性的存在，在字符串拼接或者截断操作时，不需要每次都进行内存空间的重分配，SDS在拼接完成以后，会将当前的数组长度len赋给free，表示拼接完成后数组还有len长度的空闲空间，当下次再拼接的时候，如果字符串长度小于free，那么不需要内存重分配了，如果大于free，那么再进行重分配。重分配的策略如下：如果对SDS进行修改后,SDS的长度，也就是len属性，小于1MB，那么程序分配和len相同的未使用空间，这时SDS的free和len相等。如果对SDS的修改后长度大于1MB，那么程序会分配1MB的未使用空间，比如，len属性为30MB，那么free为1MB。通过空间预分配策略，redis可以减少连续执行字符串拼接操作所需的内存重分配次数。

惰性空间释放：SDS截断操作后，redis不会释放空闲空间，而是作为free属性依然不变，下次再拼接时，不需要内存重分配，当然，如果确实要释放空间，也有相应的API操作来真正释放不需要的空间。

4.二进制安全，由于可以保存空字符在字符串中，而不像C只能放在结尾做标识，所以可以保存二进制文件，因为SDS使用len属性来判断是不是空字符串，而不是靠空字符。

### 链表

链表提供了高效的节点重排能力，以及顺序性的节点访问方式。并且可以通过增删节点来灵活地调整链表的长度。对于Redis中列表键的底层实现就是链表。除了链表键之外，发布与订阅，慢查询，监视器等功能也用到了链表。每个链表节点的定义在adlist.h/listNode结构体中定义，它定义了前置节点，后置节点，和节点值，也就意味着多个链表节点可以通过前后指针来形成双向链表。虽然可以直接使用listNode组成链表，但是redis还提供了一种结构体，adlist.h/list来持有链表，操作起来会更方便，因为这个结构体里面定义了更多的信息，比如表头结点，表尾结点，链表所包含的节点的数量，以及三个函数，节点值复制函数，节点值释放函数，节点值对比函数

综上所述：链表的实现可以总结如下：
1.双端，链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的时间复杂度为O(1)。

2.无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问是以NULL结尾，不会形成环形链表

3.带有头指针和表尾指针，通过list结构的head指针和tail指针，程序获取头尾指针的时间复杂度为O(1)

4.带有链表长度计数器，可以直接通过len属性获取链表的长度。

5.多态：链表节点使用指针来保存节点值，可以通过list结构体中的dup，free，match三个属性为节点值设置类型特定函数，所以链表可以用于保存不同类型的值

### 字典

Redis的字典所使用的哈希表由dict/dictht结构体定义：

有四个属性：分别是哈希表数组，哈希表大小，哈希表大小掩码(它总是等于size-1,用来计算哈希桶的索引位置)以及还有一个used属性，用来记录哈希表中已有的节点数量

table属性是一个数组，他里面的每一个元素都是一个指向dict.h/dictEntry的指针，每个dictEntry结构中保存着一个键值对。

哈希表节点：dict.h/dictEntry:每个dictEntry结构中保存着一个键值对，key属性保存着键值对中的键，value属性则保存着键值对中的值，其中键值对中的值既可以是一个指针，又可以是一个整数，next属性是指向另一个哈希表节点的指针，由此可见redis的哈希表也是使用链地址法解决哈希冲突问题的

字典：dict.h/dict 结构表示，在这个结构体中定义了类型特定函数，私有数据，两个哈希表，rehashindex。ht属性是一个包含两项的数组，字典一般使用ht[0]，ht[1]一般用作rehash的时候使用，除了ht[1]外，另一个与rehash有关的属性就是rehashindex，它记录rehash目前的进度，如果目前没有正在进行的rehash，那么它的值为-1；

哈希算法：hash = hashFunction()计算出来key的哈希值，然后将这个hash值&ht[0]中的sizemask，也就是hash值&size-1，从而计算除了索引值。

解决键冲突：当有两个或两个以上的键被分配到了同一个索引上时，我们就称这些键发生了冲突。redis的哈希表使用链地址法来解决哈希冲突问题，因为每个哈希表节点entry他都有一个next属性，那么多个在同一索引下的哈希表节点就可以通过next指针来连接到一起形成一个单链表从而解决冲突问题。而且为了速度考虑，每个发生冲突的节点进来后总是插入的链表的最前面，也就是头插法。

rehash：随机操作的不断执行，哈希表的节点会不断的增加或减少，为了让哈希表的负载因子维持在一个合理的范围内，当哈希表中保存的键值对数量过多或过少时应该对大小进行相应的扩展和压缩，扩展和压缩的操作通过rehash操作来完成。

1.为字典ht[1]分配内存空间，这个哈希表的大小取决于要执行的操作，以及ht[0]当前包含的键值对的数量，这个数量可以直接由used属性来获取，如果执行的是扩展操作，那么ht[1]的大小为大于等于ht[0]的used属性值*2的2的n次方，如果执行的是收缩操作，那么备用哈希表的大小为第一个大于等于已用节点的2的n次方(也就是不需要×2)。

2.将保存在ht[0]中的所有键值对rehash到备用表上面，rehash指的就是重新计算索引值和哈希值，然后将键值放置到备用表的指定位置上。

3.当ht[0]上的所有数据都迁移到了ht[1]时，ht[0]变为了空表，释放ht[0]，将ht[1]重新设置为ht[0]，并创建一个新的ht[1]作为空哈希表，为下一次rehash做好准备。

至此哈希表的rehash过程就到此结束。负载因子的计算公式为load_factor = used / size，并且当哈希表的负载因子小于0.1时，redis会自动对哈希表执行收缩操作

渐进式rehash，rehash操作不是一次性完成的。而是分多次，渐进式地完成的，原因在于当哈希表中的哈希键数量过多时，如果一次性全移到备用表，可能会导致服务器在一段时间内停止提供服务。

渐进式rehash步骤：

1.为ht[1]分配内存空间，让字典同时拥有两个哈希表，分别是ht[0]和ht[1]

2.在字典中维护了一个索引计数器变量rehashidx，并将它的值设为了0；表示rehash工作正式开始。

3.在rehash进行过程中，每次对字典执行添加，删除查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]中的键值对rehash到ht[1]中，当rehash工作完成，rehashidx值加一

4.随着字典操作的不断执行，最终在某个时间点上，ht[0]中的所有键值对最终都会被移到备用表中，这时候rehashidx值重新置为-1，表示rehash结束

渐进式哈希的好处就是避免了一次hash大量的数据造成服务器的短暂停顿，将工作量平摊到每个操作中。

注意，redis的rehash时机是：当服务器没有执行bgsave和bgwriteaof命令时，并且哈希表的负载因子大于1，那么就会自动执行rehash

或者当服务器正在执行bgsave或者bgwriteaof时，并且负载因子大于5，服务器会自动rehash。

渐进式rehash的注意点：在rehash的过程中，字典会同时使用ht[0]和ht[1]两张哈希表，当执行查询操作时，会先去ht[0]，然后再去ht[1]，如果是添加一个数据到字典中，那么会直接添加到ht[1]中，从而让ht[0]在rehash的过程中只减不增，从而最终能完成rehash，变成一张空表。

### 跳跃表

跳跃表是一种有序的数据结构，它通过在每个链表节点中维护多个指向其他节点的指针，从而可以达到快速访问其他节点的能力。跳跃表支持平均logN的查询时间复杂度，最坏On，大部分情况下，跳跃表的效率是可以和平衡树相媲美，但是它的实现比平衡树来的简单。

redis使用跳跃表来作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的是比较长的字符串，redis就会使用跳跃表来作为有序集合键的底层实现。

redis的跳跃表由zskiplist和zskiplistnode两个结构来定义：

在zskiplist结构中，保存了跳表的整体结构，比如指向跳表的表头节点和指向表尾节点的指针，还记录了当前跳表中层数最大的那个节点，不算表头节点，以及跳表的长度，不计算表头节点。

zskiplistnode结构记录了：

1.层，L1,L2,L3等字样标记了节点的各个层，L1,代表第一层，以此类推，每个层还带有两个属性，前进指针和跨度。前进指针指向了表尾方向的节点，跨度表示前进指针所指向的节点与当前节点之间的距离。

2.后退指针，节点中使用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用

3.分值，节点中保存有分值，在跳表中，节点按各自保存的分值从小到大排序

4.成员对象

跳跃表节点的level数组可以包含多个元素，每个元素包含一个指向其他节点的指针，程序可以通过这些指针来加速节点的访问速度，一般来说，层数越大，访问速度越快。

层是一个数组，数组的大小就是层的高度。redis中通过幂次定律来随机生成一个介于1到32之间的值作为层的高度，每个层都有一个前进指针和跨度。

跨度实际上是用来计算排位的，在查找节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。跳跃表中的所有节点都按照跨度来排序。比如说查找某个节点经过了两个跨度为1的节点，那么它的分值就为2

节点的成员对象是一个指针，它指向一个字符串对象，这个底层是SDS

在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的，分值相同的节点将按照成员对象在字典序中的大小来进行排序，较小的在前面。

仅靠zskiplistnode就可以构建一个跳跃表，但是最终还是通过zskiplist结构来持有这些节点，是因为程序可以更方便的对整个跳跃表进行处理，比如快速访问头结点和尾结点，也就是最大节点和最小节点或是快速获取跳表的节点数量。同时还保存了跳表中最大的节点的层数

zskiplist中的最大层高这个值记录了跳表中所有节点的最大层高，但是不计算表头节点的层高。

### 整数集合

