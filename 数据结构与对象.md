# 《Redis设计与实现--阅读笔记》

### 简单动态字符串

Redis在字符串这个数据结构上没有使用C语言提供的原生字符串，而是自己定义了一种结构体，在源码中的sds.h文件中定义，它除了底层用一个char型数据buf来存储字符以外，还维护了一个int的len属性，表示buf数组已经占用的空间大小，即字符串长度，还有一个int类型的free属性，它表示数据中还未分配的空间大小，正是由于这两个额外的属性，赋予了redis中的字符串强于C语言字符串的性能与能力。

主要性能优秀的地方体现在：

1.常数复杂度获取字符串的长度：由于内部维护了一个len属性，那么就可以直接通过len属性来获取字符串的长度，而不用像C一样要遍历字符串的每一个字符，直到遇到一个空字符结尾，才能统计出字符串的长度。将时间复杂度从O(n)缩小到了O(1)

2.杜绝了缓冲区的溢出：如果对字符串进行拼接操作，原生C字符串来拼接的时候，strcat会假设用户已经分配了足够的内存空间，一旦没有，就会发生缓冲区溢出，假设有两个相邻内存空间的C字符串，如果对第一个进行拼接操作，没有分配空间的话，那么S1的数据将会溢出到S2，造成S2的内容被修改。而SDS的API在进行修改的时候会判断内存空间是否满足需求。

3.由于free属性的存在，在字符串拼接或者截断操作时，不需要每次都进行内存空间的重分配，SDS在拼接完成以后，会将当前的数组长度len赋给free，表示拼接完成后数组还有len长度的空闲空间，当下次再拼接的时候，如果字符串长度小于free，那么不需要内存重分配了，如果大于free，那么再进行重分配。重分配的策略如下：如果对SDS进行修改后,SDS的长度，也就是len属性，小于1MB，那么程序分配和len相同的未使用空间，这时SDS的free和len相等。如果对SDS的修改后长度大于1MB，那么程序会分配1MB的未使用空间，比如，len属性为30MB，那么free为1MB。通过空间预分配策略，redis可以减少连续执行字符串拼接操作所需的内存重分配次数。

惰性空间释放：SDS截断操作后，redis不会释放空闲空间，而是作为free属性依然不变，下次再拼接时，不需要内存重分配，当然，如果确实要释放空间，也有相应的API操作来真正释放不需要的空间。

4.二进制安全，由于可以保存空字符在字符串中，而不像C只能放在结尾做标识，所以可以保存二进制文件，因为SDS使用len属性来判断是不是空字符串，而不是靠空字符。