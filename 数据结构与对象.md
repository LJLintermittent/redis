# 《Redis设计与实现--阅读笔记》

### 简单动态字符串

Redis在字符串这个数据结构上没有使用C语言提供的原生字符串，而是自己定义了一种结构体，在源码中的sds.h文件中定义，它除了底层用一个char型数据buf来存储字符以外，还维护了一个int的len属性，表示buf数组已经占用的空间大小，即字符串长度，还有一个int类型的free属性，它表示数据中还未分配的空间大小，正是由于这两个额外的属性，赋予了redis中的字符串强于C语言字符串的性能与能力。

主要性能优秀的地方体现在：

1.常数复杂度获取字符串的长度：由于内部维护了一个len属性，那么就可以直接通过len属性来获取字符串的长度，而不用像C一样要遍历字符串的每一个字符，直到遇到一个空字符结尾，才能统计出字符串的长度。将时间复杂度从O(n)缩小到了O(1)

2.杜绝了缓冲区的溢出：如果对字符串进行拼接操作，原生C字符串来拼接的时候，strcat会假设用户已经分配了足够的内存空间，一旦没有，就会发生缓冲区溢出，假设有两个相邻内存空间的C字符串，如果对第一个进行拼接操作，没有分配空间的话，那么S1的数据将会溢出到S2，造成S2的内容被修改。而SDS的API在进行修改的时候会判断内存空间是否满足需求。

3.由于free属性的存在，在字符串拼接或者截断操作时，不需要每次都进行内存空间的重分配，SDS在拼接完成以后，会将当前的数组长度len赋给free，表示拼接完成后数组还有len长度的空闲空间，当下次再拼接的时候，如果字符串长度小于free，那么不需要内存重分配了，如果大于free，那么再进行重分配。重分配的策略如下：如果对SDS进行修改后,SDS的长度，也就是len属性，小于1MB，那么程序分配和len相同的未使用空间，这时SDS的free和len相等。如果对SDS的修改后长度大于1MB，那么程序会分配1MB的未使用空间，比如，len属性为30MB，那么free为1MB。通过空间预分配策略，redis可以减少连续执行字符串拼接操作所需的内存重分配次数。

惰性空间释放：SDS截断操作后，redis不会释放空闲空间，而是作为free属性依然不变，下次再拼接时，不需要内存重分配，当然，如果确实要释放空间，也有相应的API操作来真正释放不需要的空间。

4.二进制安全，由于可以保存空字符在字符串中，而不像C只能放在结尾做标识，所以可以保存二进制文件，因为SDS使用len属性来判断是不是空字符串，而不是靠空字符。

### 链表

链表提供了高效的节点重排能力，以及顺序性的节点访问方式。并且可以通过增删节点来灵活地调整链表的长度。对于Redis中列表键的底层实现就是链表。除了链表键之外，发布与订阅，慢查询，监视器等功能也用到了链表。每个链表节点的定义在adlist.h/listNode结构体中定义，它定义了前置节点，后置节点，和节点值，也就意味着多个链表节点可以通过前后指针来形成双向链表。虽然可以直接使用listNode组成链表，但是redis还提供了一种结构体，adlist.h/list来持有链表，操作起来会更方便，因为这个结构体里面定义了更多的信息，比如表头结点，表尾结点，链表所包含的节点的数量，以及三个函数，节点值复制函数，节点值释放函数，节点值对比函数

综上所述：链表的实现可以总结如下：
1.双端，链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的时间复杂度为O(1)。

2.无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问是以NULL结尾，不会形成环形链表

3.带有头指针和表尾指针，通过list结构的head指针和tail指针，程序获取头尾指针的时间复杂度为O(1)

4.带有链表长度计数器，可以直接通过len属性获取链表的长度。

5.多态：链表节点使用指针来保存节点值，可以通过list结构体中的dup，free，match三个属性为节点值设置类型特定函数，所以链表可以用于保存不同类型的值

### 字典

Redis的字典所使用的哈希表由dict/dictht结构体定义：

有四个属性：分别是哈希表数组，哈希表大小，哈希表大小掩码(它总是等于size-1,用来计算哈希桶的索引位置)以及还有一个used属性，用来记录哈希表中已有的节点数量

table属性是一个数组，他里面的每一个元素都是一个指向dict.h/dictEntry的指针，每个dictEntry结构中保存着一个键值对。

哈希表节点：dict.h/dictEntry:每个dictEntry结构中保存着一个键值对，key属性保存着键值对中的键，value属性则保存着键值对中的值，其中键值对中的值既可以是一个指针，又可以是一个整数，next属性是指向另一个哈希表节点的指针，由此可见redis的哈希表也是使用链地址法解决哈希冲突问题的

字典：dict.h/dict 结构表示，在这个结构体中定义了类型特定函数，私有数据，两个哈希表，rehashindex。ht属性是一个包含两项的数组，字典一般使用ht[0]，ht[1]一般用作rehash的时候使用，除了ht[1]外，另一个与rehash有关的属性就是rehashindex，它记录rehash目前的进度，如果目前没有正在进行的rehash，那么它的值为-1；

哈希算法：hash = hashFunction()计算出来key的哈希值，然后将这个hash值&ht[0]中的sizemask，也就是hash值&size-1，从而计算除了索引值。

解决键冲突：当有两个或两个以上的键被分配到了同一个索引上时，我们就称这些键发生了冲突。redis的哈希表使用链地址法来解决哈希冲突问题，因为每个哈希表节点entry他都有一个next属性，那么多个在同一索引下的哈希表节点就可以通过next指针来连接到一起形成一个单链表从而解决冲突问题。而且为了速度考虑，每个发生冲突的节点进来后总是插入的链表的最前面，也就是头插法。

rehash：随机操作的不断执行，哈希表的节点会不断的增加或减少，为了让哈希表的负载因子维持在一个合理的范围内，当哈希表中保存的键值对数量过多或过少时应该对大小进行相应的扩展和压缩，扩展和压缩的操作通过rehash操作来完成。

1.为字典ht[1]分配内存空间，这个哈希表的大小取决于要执行的操作，以及ht[0]当前包含的键值对的数量，这个数量可以直接由used属性来获取，如果执行的是扩展操作，那么ht[1]的大小为大于等于ht[0]的used属性值*2的2的n次方，如果执行的是收缩操作，那么备用哈希表的大小为第一个大于等于已用节点的2的n次方(也就是不需要×2)。

2.将保存在ht[0]中的所有键值对rehash到备用表上面，rehash指的就是重新计算索引值和哈希值，然后将键值放置到备用表的指定位置上。

3.当ht[0]上的所有数据都迁移到了ht[1]时，ht[0]变为了空表，释放ht[0]，将ht[1]重新设置为ht[0]，并创建一个新的ht[1]作为空哈希表，为下一次rehash做好准备。

至此哈希表的rehash过程就到此结束。负载因子的计算公式为load_factor = used / size，并且当哈希表的负载因子小于0.1时，redis会自动对哈希表执行收缩操作

渐进式rehash，rehash操作不是一次性完成的。而是分多次，渐进式地完成的，原因在于当哈希表中的哈希键数量过多时，如果一次性全移到备用表，可能会导致服务器在一段时间内停止提供服务。

渐进式rehash步骤：

1.为ht[1]分配内存空间，让字典同时拥有两个哈希表，分别是ht[0]和ht[1]

2.在字典中维护了一个索引计数器变量rehashidx，并将它的值设为了0；表示rehash工作正式开始。

3.在rehash进行过程中，每次对字典执行添加，删除查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]中的键值对rehash到ht[1]中，当rehash工作完成，rehashidx值加一

4.随着字典操作的不断执行，最终在某个时间点上，ht[0]中的所有键值对最终都会被移到备用表中，这时候rehashidx值重新置为-1，表示rehash结束

渐进式哈希的好处就是避免了一次hash大量的数据造成服务器的短暂停顿，将工作量平摊到每个操作中。

注意，redis的rehash时机是：当服务器没有执行bgsave和bgwriteaof命令时，并且哈希表的负载因子大于1，那么就会自动执行rehash

或者当服务器正在执行bgsave或者bgwriteaof时，并且负载因子大于5，服务器会自动rehash。

渐进式rehash的注意点：在rehash的过程中，字典会同时使用ht[0]和ht[1]两张哈希表，当执行查询操作时，会先去ht[0]，然后再去ht[1]，如果是添加一个数据到字典中，那么会直接添加到ht[1]中，从而让ht[0]在rehash的过程中只减不增，从而最终能完成rehash，变成一张空表。

### 跳跃表

跳跃表是一种有序的数据结构，它通过在每个链表节点中维护多个指向其他节点的指针，从而可以达到快速访问其他节点的能力。跳跃表支持平均logN的查询时间复杂度，最坏On，大部分情况下，跳跃表的效率是可以和平衡树相媲美，但是它的实现比平衡树来的简单。

redis使用跳跃表来作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的是比较长的字符串，redis就会使用跳跃表来作为有序集合键的底层实现。

redis的跳跃表由zskiplist和zskiplistnode两个结构来定义：

在zskiplist结构中，保存了跳表的整体结构，比如指向跳表的表头节点和指向表尾节点的指针，还记录了当前跳表中层数最大的那个节点，不算表头节点，以及跳表的长度，不计算表头节点。

zskiplistnode结构记录了：

1.层，L1,L2,L3等字样标记了节点的各个层，L1,代表第一层，以此类推，每个层还带有两个属性，前进指针和跨度。前进指针指向了表尾方向的节点，跨度表示前进指针所指向的节点与当前节点之间的距离。

2.后退指针，节点中使用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用

3.分值，节点中保存有分值，在跳表中，节点按各自保存的分值从小到大排序

4.成员对象

跳跃表节点的level数组可以包含多个元素，每个元素包含一个指向其他节点的指针，程序可以通过这些指针来加速节点的访问速度，一般来说，层数越大，访问速度越快。

层是一个数组，数组的大小就是层的高度。redis中通过幂次定律来随机生成一个介于1到32之间的值作为层的高度，每个层都有一个前进指针和跨度。

跨度实际上是用来计算排位的，在查找节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。跳跃表中的所有节点都按照跨度来排序。比如说查找某个节点经过了两个跨度为1的节点，那么它的分值就为2

节点的成员对象是一个指针，它指向一个字符串对象，这个底层是SDS

在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的，分值相同的节点将按照成员对象在字典序中的大小来进行排序，较小的在前面。

仅靠zskiplistnode就可以构建一个跳跃表，但是最终还是通过zskiplist结构来持有这些节点，是因为程序可以更方便的对整个跳跃表进行处理，比如快速访问头结点和尾结点，也就是最大节点和最小节点或是快速获取跳表的节点数量。同时还保存了跳表中最大的节点的层数

zskiplist中的最大层高这个值记录了跳表中所有节点的最大层高，但是不计算表头节点的层高。

### 整数集合

整数集合是集合键的底层实现，当一个集合只包含整数元素，并且集合的元素不多的时候。redis就会使用整数集合作为集合键的底层实现

~~~c
typedef struct intset{
    uint32_t encoding;
    uint32_t length;
    int8_t contens[];
}
~~~

整数集合时redis用于保存整数值的集合抽象数据结构，他可以保存类型为16位，32位和64位的整数，对应于java中short int 和long的取值范围，虽然这个contents数组声明为8位，但是数组中保存的元素的类型是取决于encoding属性的值的。而这个encoding的值取决于数组中最大元素的位数，如果最大元素时64位，那么这个数组就是一个64位数组。其中每一个元素也会从原来的类型变为64位

升级：

每当要添加一个新元素到集合中，首先要判断元素类型是否大于当前的encoding值，来决定是否扩充数组的空间大小，并为新元素分配空间，然后将所有元素都转换成与新元素相同的类型，并将类型转换以后的元素放置正确的位置上，放置的过程中必须维护底层数组的有序性，最终将新元素添加到数组中

整数集合升级机制的好处：

1.提升灵活性，为了避免类型出错，因为C语言是静态类型语言，通常不会将不同类型的数据放在一个数据结构中，那么整数集合底层通过升级机制可以更加灵活的放置所有类型的整数，不需要担心类型错误

2.节约内存，如果要让一个数组能保存所有位的整数，那么最简单的是直接建立一个64位的整数数组，这样可以保存所有16为，32位和64位的数字，但是不免造成空间的浪费，有了升级机制以后，相当于是一个惰性空间开辟，只有你没有大到该扩展下一个大位数的阶段，那么就用可以存的下的类型数组来存，可以达到既能存储多个类型，又能尽量节省空间的效果

整数集合时不支持降级的。

整数集合的底层实现是数组，且是有序无重复的方式保存元素

### 压缩列表

压缩列表是列表键和哈希键的底层实现之一。当一个列表键只含有少量的列表项，并且每一项要么是小整数值，要么是长度比较短的字符串时，redis就会使用压缩列表来做列表键的底层实现

同时当一个哈希键只包含少量的键值对时，并且每个键值对的键和值要么是小整数值，要么是长度比较短的字符串，那么哈希键的底层实现就会使用压缩列表

压缩列表是redis为了节约内存而开发，是由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以由一个字节数组或者一个整数值组成

压缩列表的组成结构：

zlbytes：记录整个压缩列表占用的空间，在对压缩列表进行内存重分配的时候使用或者计算zlend的位置时使用

zltail：记录压缩列表的表尾节点距离列表的起始地址有多远，通过这个偏移量，程序无法遍历整个链表就可以确定尾结点的位置

zllen：记录了压缩列表包含的节点数量

entry：压缩列表包含的各个节点

zlend：特殊值，用于标记压缩列表的末端

每个压缩列表的节点可以保存一个字节数组机或者一个整数值，每个节点有三个部分组成，分别是previous_entry_length，encoding，content。

previous_entry_length

第一个长度属性记录了上一个压缩列表节点的长度，这个属性的长度可以是1个字节或者5个字节，如果前一个节点的长度小于254字节，那么这个属性就是一字节，如果前一个节点的长度大于254字节，那么这个属性就是5字节。压缩链表的从尾到头的遍历原理就是根据这个属性来实现，只要拥有了一个指向某个节点的起始地址的指针，就可以通过指针减去这个属性值来回到上一个节点的起始位置

encoding

节点的encoding属性记录了节点的content所保存的数据的类型和类型，这个编码类似于11000000，一个字节长度，表示int_16整数

所以编码不仅可以表示数据类型，还可以表示长度

content

节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数值，值的类型和长度由节点的encoding属性保存

由于previous_entry_length属性的值会根据前一个节点的大小而决定，所以当这个属性变化，并且当前节点的大小正好处于250-253字节时，那么会如果前面加了一个大于254字节长度entry，那么后面entry的previous_entry_length属性值可能会增大，造成自己这个entry增大，然后引发连锁更新，如果是极端情况，后面的每一个节点都是在250到253字节，那么会造成大范围连锁更新，连锁更新的话程序会不断的进行内存重分配的过程，但是这个条件比较苛刻，所以不用太过在意

### 对象

前面了解到redis中主要使用的五种数据结构的底层实现，比如SDS，双端链表，字典，压缩列表，跳表，整数集合等，但是redis并没有直接使用这些数据结构，而是在最上层创建了一个对象系统，这个对象系统包含字符串对象，哈希对象等，而每一个对象都至少使用到了一种上面提到的数据结构

通过基础的五种对象，redis可以在执行命令的时候，根据对象的类型来判断一个对象是否可以执行给定的命令，使用对象我认为最大的好处就是可以根据不同的使用场景，来动态的切换底层数据结构，从而达到对症下药的目的。另外redis的对象通过引用计数算法进行内存回收，当程序没有对象引用这个对象时，这个对象会被释放掉内存，并且借用了引用计数这个属性，redis还实现了对象共享机制，可以多个数据库键来共享同一个对象

redis使用对象来表示数据库中的键和值，每次创建一个kv，都至少会创建两个对象，一个对象是键对象，一个对象是值对象。redis的每个对象都是用一个redisobject结构来表示

~~~c
typedef struct redisObject {
    unsigned type:4;// 类型：字符串、列表、哈希、集合、有序集合
    /**
    * 编码：long类型的整数、embstr编码的简单动态字符串、简单动态字符串、字典、双端链表、压缩列表、整数集合、跳表
    * ** 不同类型对应的编码
    * **** 字符串：long类型的整数、embstr编码的简单动态字符串、简单动态字符串
    * **** 列表：压缩列表、双端链表
    * **** 哈希：压缩列表、字典
    * **** 集合：整数集合、字典
    * **** 有序集合：压缩列表、跳表
    *
    * 通过# object encoding key 指令可输出对应的编码
    **/
    unsigned encoding:4;
    //内存淘汰策略相关
    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or
                            * LFU data (least significant 8 bits frequency
                            * and most significant 16 bits access time). */
    int refcount;// 引用计数
    void *ptr;// 指向底层数据实现的指针
} robj;
~~~

#### 类型

对象的type属性记录了对象的类型，这个常量对应五种基本数据类型，字符串、列表、哈希、集合、有序集合

对于redis来说每一个键对象都是一个字符串对象，而值则可以是字符串对象，列表对象等任何一种，而通常所说的我们使用一种数据类型，说的是这个kv的v他是什么对象，当称呼一个键为哈希键，那么指的是这个字符串对象键对对应的值对象是一个哈希对象，所以我们说建立了一个哈希键。当在redis中使用type命令来type某一个key返回的结果也是值对象的类型，而不是键对象类型，键对象类型都是字符串对象

#### 编码

redisobject的ptr指针指向底层实现的数据结构，而这些数据结构由对象的encoding属性决定，encoding属性记录了对象所使用的编码，编码决定数据结构，使用object encoding命令可以查看一个键所对应的值对象的底层数据结构实现，那么redis这样设计极大的提高了数据类型的使用上的灵活性，可以针对使用情况来切换数据结构，这是我认为redis数据结构这块设计最巧妙的一点

redis根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的使用效率，举个例子：

在列表元素较少的时候，redis使用压缩列表来作为列表对象的底层实现

因为压缩列表比双端列表更加节约空间，在元素较少的时候，内存空间连续的压缩列表可以比双端列表更快的载入到内存中

随着列表对象的越来越多，双端链表更适合保存。

### 五种对象的编码和对应的数据结构

### 字符串对象

字符串对象的编码可以是raw，embstr，和int

如果一个字符串对象保存的是整数值，并且这个整数值可以用long来表示，那么字符串对象会直接将整数值保存在字符串对象的ptr指针的指向中，并且这个字符串的编码会被设置为int，也就是说一个字符串对象它的ptr直接指向一个数字，比如10000

如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于39字节，那么将用embstr编码，这是专门用来保存短字符串的一种优化编码方式，虽然embstr和raw格式都是使用redisobject和sdshdr结构来表示字符串对象，但是raw编码会调用两次内存分配函数来分别创建redisobject和sdshdr结构，而embstr只会调用一次内存分配

字符串对象编码的转换：

对于字符串对象，比如使用append命令来拼接到一个int编码后面，那么此时字符串对象的编码要变为raw，对于embstr编码，其实是只读的，也就是对于它的任何改变，都会首先变为raw然后在操作

### 列表对象

列表对象的编码可以是ziplist或者linkedlist，ziplist编码底层是压缩列表，linkedlist底层是双端链表

压缩列表对象的每个压缩列表节点entry保存了一个列表的元素，也就是它的ptr指向，是一个完整的压缩列表的结构。

对于双端链表的节点，它的每一个节点对象的包装使用一个字符串对象，相当于每个双端链表节点都保存了一个字符串对象，而每个字符串对象保存了一个列表元素

注意，对于列表对象的linkedlist编码实现，它内部嵌套了字符串对象，这种方式在后面的哈希键，集合键，有序集合键都会使用到，而字符串是redis五种基本数据类型中唯一一种会被其他对象嵌套的对象

编码转换：

当列表对象保存的所有字符串元素的长度都小于64字节

列表对象所保存的元素的总数量小于512个

对于压缩列表，如果以上两个条件任意一个不满足，都会执行对象的编码转换，原本保存在压缩列表中的所有列表元素都会被转移到双端链表。

### 哈希对象

哈希对象的编码可以是ziplist和hashtable

ziplist编码的哈希对象底层使用压缩链表作为底层实现，每当有新的键值要加入的哈希对象中时，会将键的压缩列表推到列表尾部，然后再将值的压缩列表推到列表尾部，所以同一对键值对的两个节点总是紧挨在一起，保存键的节点在保存值的节点之前

另一方面，哈希对象的编码如果是hashtable，底层就是字典，哈希对象的每一个键值都是用一个字典键值对来表示。

而字典中的每个键都是一个字符串对象，对象中保存了键值对的键

字典中的每个值也都是一个字符串对象，保存了键值对的值

编码转换：

当哈希对象保存的所有键值对的字符串长度都小于64字节

哈希对象保存的键值对数量小于512个

当上面两个条件同时满足，就会使用ziplist编码来实现哈希键，如果有一个不满足，就会使用hashtable编码来实现

### 集合对象



