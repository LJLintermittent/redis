## 复制

在redsis中，用户可以通过slaveof + ip地址 + 端口号的方式在从服务器上执行，ip地址加端口号指定的是主服务器的，从而可以实现主从复制，去别的服务器复制的叫从服务器，提供给别人复制的是主服务器

进行主从复制的服务器之间应该保证数据的一致性。

### redis2.8以前的旧版复制原理

redis的复制功能可以分为同步和命令传播两部分：

1.同步操作用于将从服务器的状态更新到主服务器的状态

2.命令传播作用是在主服务器又增加了新的写命令后，需要将这个命令也传播给从服务器

#### 同步

当客户端向从服务器发送slaveof命令时，就是要求从服务器复制主服务器，那么从服务器需要首先进行一个同步操作，也就是将主服务器的状态更新到从服务器的，以此达到数据的一致性

从服务器对主服务器的同步操作是通过sync命令来完成的，步骤：

1.从服务器向主服务器发送sync命令

2.收到sync命令的主服务器开始执行bgsave命令，生成一个rdb文件，并使用一个缓冲区记录在生成rdb文件的这段时间新生成的写命令

3.当主服务器的bgsave执行完以后，主服务器会把这个生成的rdb文件发送给从服务器，从服务器载入这个rdb文件，主服务器还要发送缓冲区里面记录的写命令，从服务器收到以后执行完毕，这时候两个服务器的状态就达到了一致

#### 命令传播

经过同步后，两个服务器达到了短暂的一致，但是主服务器还会不断的接收新来的写命令，所以主服务器还要将命令传播到所有的从服务器，以此来维持住同步状态。

#### 旧版复制原理

在redis2.8以前，从服务器对主服务器的复制可以分为两种情况：

1.初次复制：从服务器以前没有复制过，或者当前要复制的主服务器和以前复制的主服务器不同

2.断线后重复制：处于命令传播阶段的主从服务器如果断开了网络连接，然后从服务器经过一段时间又恢复了网络连接，那么需要继续复制

对于初次复制，旧版的复制可以比较好的完成工作，但对于这个断线后重复制，旧版的效率太低下

因为断线重连后，从服务器还是使用sync命令进行完整复制，重复一遍生成rdb文件，写缓冲区等等这个流程，其实断线重连后只需要恢复断线的这个时间段主服务器新写进来的命令就OK了

~~~wiki
sync是一项非常耗费资源的操作
在复制的时候，每次执行sync命令，将会发生如下操作：
1.主服务器需要执行bgsave来生成rdb，这个操作会耗费大量主服务器的cpu，内存，磁盘io资源
2.主服务器需要将生成的rdb文件发送给从服务器，这个过程会耗费主从服务器大量的网络资源，并对主服务器的命令响应产生影响
3.接收到的rdb文件载入到从服务器，从服务器在rdb载入期间丧失所有读写能力
所以sync是一个很重的操作，所以尽量只在有必要的时候才执行sync
而断线重连恢复部分数据这种场景，很明显就不需要sync
~~~

#### 新版复制原理

新版使用psync代替sync

psync具有完整重同步和部分重同步两个功能

其中完整重同步用于处理初次复制情况，完整重同步的执行步骤和执行sync的步骤一样，都是让主服务器创建rdb文件，以及发送缓存区里面的写命令来进行同步

而部分重同步用于断线重连这种情况，当从服务器断线重连后，如果条件允许，主服务器将把断开后执行的命令发送给从服务器，从服务器只要接收并执行这些命令，就可以恢复到一致状态。

psync命令的部分重同步模式解决了旧版复制功能在处理断线能力方面效率低下的问题

#### 部分重同步的实现原理

部分重同步功能主要由三个部分组成：

1.主服务器的复制偏移量和从服务器的复制偏移量

2.主服务器的复制积压缓冲区

3.runid，每个服务器一个特定的id

复制偏移量

用来记录复制到了哪里，比如主服务器的offset是1000，从服务器的offset也是1000的话，那么说明两个服务器此时的状态是一致的。如果主服务器新增了写命令，那么offset会相应的增大。

如果在断线前主从服务器之间的复制偏移量是一致的，然后主从之间断开了连接，那么主服务器的偏移量会在这个阶段增加，当从服务器连接上来后将会向主服务器发送psync命令。

#### 复制积压缓冲区

复制积压缓冲区是一个由主服务器维护的FIFO先进先出的一个队列，并且大小默认是1M，长度是固定的，不会动态扩容

当主服务器进行命令传播的时候，不仅要把命令发送给所有的从服务器，还会将命令写入到复制积压缓冲区，复制积压缓冲区会保存部分最近发送的命令，并且复制积压缓冲区里面的每个字节都会对应一个准确的偏移量，用来做准确的部分重同步

当从服务器连接上来后，从服务器通过psync将自己的复制偏移量也带上，主服务器根据这个复制偏移量来决定进行哪种模式的psync

如果offset偏移量之后的数据仍然在缓冲区，那么进行部分重同步

如果offset偏移量之后的数据不在缓冲区了，说明已经断线很久了，那么复制积压缓冲区都已经没有存下，那么需要执行完整重同步

主服务器检查后发现应该是部分重同步，那么恢复一个+continue，然后主服务器会将积压缓冲区中这个偏移量后面的数据给从服务器发过去。从服务器只会接收丢失部分的数据，大大提高了断线复制的效率

另外这个积压缓冲区需要根据断线时间+主服务器写入速率的乘积来做一个设置

以此来尽量让所有的断线恢复都能在复制积压缓冲区中找到偏移量

#### 服务器运行ID

除了复制偏移量和复制积压缓冲区以外，实现部分重同步还需要带上runid，如果断线重连后从服务器发来的runid（发来的这个runid是保存的主服务器的runid）等于现在的主服务器id，那么说明断线前你的主服务器就是我，所以执行部分重同步，否则完整重同步

这个runid是当从服务器对主服务器进行初次复制时，主服务器会将自己的runid传送给从服务器，从服务器进行psync命令发送的时候需要带上这个runid。

psync的格式是 psync  runid offset，进行复制的时候除了确认这些参数以外，在真正复制之前还有一次握手的过程，+continue回复

#### 复制的完整实现

#### 1.设置主服务器的地址和端口号 salveof 127.0.0.1 6379

#### 2.建立socket连接

在slaveof命令执行以后，从服务器将根据命令所设置的ip地址和端口号，创建连向主服务器的套接字连接

如果从服务器创建的socket连接能成功连接到主服务器，那么从服务器将为这个套接字关联一个专门用于处理复制工作的文件事件处理器，这个处理器将负责执行之后的复制工作，比如接收rdb文件以及接收来的传播命令等

而主服务器在accept从服务器的套接字连接之后，将为该套接字创建相应的客户端状态，并将从服务器看做是一个客户端来对待，这时从服务器将具有服务器和客户端两个状态，从服务器可以向主服务器发送命令。

#### 3.发送ping命令

从服务器成为主服务器的客户端后，做的第一个事情就是发送ping命令，这个ping命令有两个作用：

1.虽然建立了套接字连接，但是双方并未使用该套接字进行任何网络通信，通过发送ping命令来检查套接字的读写状态是否正常

2.如果主服务器向从服务器返回一个命令回复，但从服务却不能在规定的时间内读取，当出现这种情况，需要断开连接

如果主服务器向从服务器返回一个错误，那么表示主服务器暂时没有办法处理从服务器的命令请求，不能执行复制的后序操作

如果从服务器读到了pong命令,那么表示主从服务器之间的网络连接状态是一致的,这种情况下,可以继续执行后序的复制操作

注意,如果ping后回复超时或者主服务器返回一个错误,那么从服务器会断开并重连

#### 4.身份验证

从服务器收到pong后,然后就是根据服务器的配置决定是否进行身份验证

masterauth和requirespass选项决定是否需要认证以及是否需要密码

#### 5.发送端口信息

身份验证后从服务器将向主服务器发送从服务器的监听端口号

主服务器在收到以后,会将端口号记录在从服务器对应的客户端状态的属性中

#### 6.同步

在这一步从服务器将向主服务器发送psync命令,执行同步操作.

需要注意的是在执行psync命令前只有从服务器是主服务的客户端,到了这一步,两者互为对方的客户端

正因为主服务器成为了从服务器的客户端,所以主服务器才可以通过发送写命令来改变从从服务器的状态

#### 7.命令传播

完成了同步后,就进入了命令传播阶段,这时主服务器只要一直将自己执行的写命令发送给从服务器,而从服务一直接收来自主服务器的命令,那么两者就可以一直是一致状态

### 心跳检测

在命令传播阶段,从服务器默认会以每秒一次的频率,向主服务器发送命令

replconf ack <replication offset>

其中replication offset就是从服务的当前复制偏移量

replconf ack 这个命令有三个作用:
1.检测主从网络连接状态

2.辅助实现min-slaves

3.检测命令丢失

第一点不用说,主要说二三点:
辅助实现min-slaves,redis的min-slaves-to-write和min-slaves-max-log选项可以让主服务器在不安全的情况下,停止写命令

min-slaves-to-write 设置为3,min-slaves-max-log设置为10,代表的意思从服务器的数量少于三个,或者三个从服务器的延迟值都大于或等于10,那么主服务器将拒绝执行写命令

另外replconf ack 后面带上的偏移量还可以检测在这一秒内主服务器有没有丢失命令

如果发现偏移量不一致,那么可能是主服务传播命令丢失了,需要补发数据

这个补发数据的原理和部分重同步的原理差不多,区别就是一个是断线了,一个没断线

在redis2.8以前,如果命令在传播过程中丢失了,那么主服务器和从服务器都不会注意到

所以为了保证数据的一致性,最好选用redis2.8以上版本

~~~wiki
复制部分总结:
部分重同步通过复制偏移量和复制积压缓冲区和runid三个来实现
在复制刚开始时,从服务器会成为主服务器的客户端,并通过向主服务器发送命令来执行复制的前面的步骤,而到了同步阶段,两者互为主从
并且还有心跳检测机制,防止数据丢失
~~~

## 哨兵

sentinel是redis高可用的解决方法，真实场景会有一个或多个sentinel实例组成的sentinel系统来监控任意多个主服务器，以及这些主服务器下的从服务器，并在被监视的主服务器下线后，自动将这个主服务器下的从服务器中的某一个升级为新的主服务器，这个下线的旧的主服务器会被sentinel设置为从服务器slave类型，如果重新上线了，那么它会作为一个从服务器，这个被称作故障转移

当某一个服务器的下线时长超过用户设置的下线时长上限时，sentinel系统就会对这个下线的服务器进行故障转移操作

首先sentinel系统会挑选它的属下的一台服务器，将这个服务器升级为主服务器

之后sentinel会向下线的服务器的所有下属发送复制命令，让他们成为新的主服务器的从服务器，当所有的从服务器都开始复制新的主服务器时，故障转移操作执行完毕

另外，sentinel还会继续监视已经下线的那个服务器，他重新上线后会成为新的主服务器的从服务器

启动一个sentinel的命令：redis-sentinel  ./././sentinel.conf

当一个sentinel启动的时候，它的步骤如下：

1.初始化服务器

2.将普通的redis服务器使用的命令表转换为sentinel服务器使用的命令表

3.初始化sentinel状态

4.根据给定的配置文件，初始化sentinel的监视主服务器列表

5.创建连向主服务器的网络连接

接下来详细总结启动sentinel的细节：

#### 初始化服务器

首先，sentinel本质上就是一个运行在特殊模式下的redis服务器，所以启动sentinel的第一步就是初始化一个普通的redis服务器，但是因为sentinel服务器的执行方式和redis服务器的不同，所以在初始化服务器的时候会有一些不同，比如redis服务器在初始化的时候需要载入rdb文件或者aof文件来还原数据库状态，而sentinel不使用数据库功能，所以sentinel服务器初始化的时候不载入aof和rdb文件

#### 使用sentinel专用代码

启动sentinel的第二步就是将一部分普通redis服务器使用的代码替换成sentinel的专用代码，比如端口号的配置常量，redis默认是6379，sentinel服务器默认是26379，除此以外，普通redis使用的命令表和sentinel服务器不同，实际上sentinel的命令表里面只有七个命令，也就是说客户端只能对sentinel使用7个命令：ping，sentinel，info，subscribe，unsubscribe，psubscribe，punsubscribe这七个命令，sentinel使用的命令表是sentinelcmds，普通redis服务器使用的命令表是rediscommandtable

#### 初始化sentinel状态

在应用了sentinel的专用代码后，服务器会初始化一个sentinel.c/sentinelState，简称sentinel状态，这个结构保存了服务器中和sentinel所有有关的配置，里面比较重要的是dict结构的masters，这是一个字典结构，字典键是主服务器的名字，值是一个指向sentinelredisinstance的实例。

#### 初始化sentinel状态中masters属性

这个masters属性表示了sentinel所监视的所有主服务器。从sentinel的介绍图上一般能看到sentinel也会监视到从服务器，但这里面没有保存从服务器的原因就是，由于主服务器会保存自己属下的所有从服务器，那么sentinel只要和主服务器建立了连接后，就可以从主服务器中拿到从服务器的信息，从而建立监视，其实就是两个连接，命令连接和订阅连接

说回字典结构，这个masters字典里保存了所有被sentinel监视的主服务器的相关信息

重点说字典的值，值指向的是主服务器的sentinelredisinstance结构，简称实例结构，这个实例结构可以是主服务器，从服务器，也可以是另一台sentinel实例，实例包含的属性的非常多：
flags：实例的类型，以及该实例的当前状态

name 实例名字，主服务器的名字由用户在配置文件中设置

runid：实例的运行id

config_epoch 配置纪元，用于实现故障转移的

addr：实例的地址

down after milliseconds 实例无响应多长时间后会被sentinel判断为主观下线，（非常重要）

。。。

对sentinel状态的初始化引发了对masters字典的初始化，而masters字典的初始化是根据被载入的sentinel配置文件来进行的，最终配置文件中信息会被载入到sentinel.c/sentinelState中的masters属性中，这个属性底层是字典实现的

#### 创建连向主服务器的网络连接

初始化sentinel的最后一步就是创建连接，sentinel将成为主服务器的一个客户端，它会向主服务器发送命令，并从命令回复中获取相关信息。需要注意的是：对于每个被sentinel监视的主服务器来说，sentinel都会和他们建立两个连接：
1.一个是专门用来发送命令的连接，并接受命令回复

2.另一个订阅连接，来订阅主服务器的sentinel hello频道

~~~wiki
为什么会有两个连接？
在redis目前（redis2.8）的发布订阅功能中，被发送的信息都不会保存在redis服务器里面，如果在信息发送时，想要接收信息的客户端不在线或者断线，那么这个信息就会丢失，因此为了不丢失sentinel hello频道中的任何信息，sentinel必须使用一个专用的订阅连接来接收该频道的信息
除了这个订阅连接必须存在以外，sentinel还必须向主服务器发送命令，以此来和主服务器进行通信，那么还必须建立命令连接
因为sentinel需要与多个服务器实例之间进行通信，所以sentinel使用的异步连接
~~~

以上就是sentinel服务器初始化的过程，至此sentinel服务器创建完成并与所有配置文件中配置好的主服务器之间建立起了连接

接下来就是sentinel与主服务器之间通信的细节：

#### 获取主服务器的信息

sentinel在正常状态下默认会以10秒一次的频率，向主服务器发送info命令，从命令回复中可以获取到主服务器本身的信息，以及这个主服务器的所有从服务器的信息，信息主要是记录了ip+端口号，状态online，offset以及lag，lag是响应时间

正因为可以通过这种方式获取到从服务器的信息，所以在玩的时候不需要在配置文件中配置从服务器的信息，就可以自动的发现从服务器，sentinel就会根据info回来的信息，对主服务器的结构实例sentinelredisinstance进行更新，至于主服务器返回来的所有从服务器信息，sentinel会将其更新到实例结构中的salves字典中去，这个salves字典中的键是sentinel自动设置的从服务器的名字，值是从服务器对应的实例结构

主服务器的实例结构的flags属性的值为SRI_master，从服务器的实例结构的flags属性的值是SRI_slave

主服务器的实例结构的name属性的值是sentinel配置文件中配置，从服务器的实例结构的name属性的值是sentinel系统根据从服务器的ip地址和端口号自动设置的

另外当sentinel发现主服务器有新的从服务器出现的时候，通过info命令的回复拿到新的从服务器信息，并将其设置在主服务器的sentinelredisinstance结构中的slaves字典中



~~~c
sentinelState{
	dict masters{
        主服务器名 ： sentinelredisinstance{
            				dict slaves{
                            		从服务器名 ： sentinelredisinstance
                        		}
    				}
}
~~~

#### 获取从服务的信息

当sentinel发现主服务器有新的从服务器出现时，sentinel除了会为这个新的从服务器创建相应的实例结构外，sentinel还会创建连接到从服务器的命令连接和订阅连接

每十秒一次的频率向主服务器发送info命令，根据info命令的回复，sentinel来提取一些信息，从这些信息中，sentinel对从服务器的实例结构进行更新

#### 向主服务器和从服务器发送信息

默认情况下，sentinel会每两秒一次的频率向sentinel hello频道发送消息。

#### 接收来自主服务器和从服务器的频道信息

当sentinel与一个主服务器或者从服务器建立起订阅连接后，sentinel就会通过订阅连接，向服务器发送 subcribe sentinel hello

sentinel对频道sentinel hello的订阅会一直持续到sentinel与服务器的连接断开为止

也就是说对于每个与sentinel连接的服务器，sentinel既能通过命令连接向服务器的sentinel hello 频道发送消息，也能订阅服务器的sentinel hello发来的消息

对于监视同一个服务器的多个sentinel来说，一个sentinel发送的消息也会被其他的sentinel接收到，这些消息会被用于更新其他sentinel对发送信息sentinel的认知，也会被用于更新其他sentinel对被监视服务器的认知

举个例子：假设现在有s1，s2，s3三台sentinel服务器在监视同一个服务器，那么当s1,向服务器的sentinel hello频道发送消息时，所有订阅了sentinel hello频道的sentinel包括自己都会收到这条消息，只不过如果自己发现这条消息是自己发送的，那么会丢弃，因为id相同

#### 更新sentinels字典

sentinel为主服务器创建的实例结构中的sentinels字典保存除sentinel本身外，还有所有同样监视了这个主服务器的sentinel信息

因为一个sentinel可以通过分析接收到的频道的信息来获知其他sentinel的存在，并通过发送频道信息来让其他sentinel知道自己的存在，所以用户在使用的sentinel的时候并不需要提供各个sentinel的地址信息，监视同一个主服务器的sentinel可以互相发现对方

sentinel之间也会创建连接，不过只会创建命令连接，不会创建订阅连接

~~~wiki
sentinel在连接主服务器或者从服务器的时候，需要创建订阅和命令连接，但是连接其他sentinel的时候只会创建命令，因为sentnel需要接收来自主服务器或者从服务器的频道信息，来发现未知的sentinel，所以才需要建立订阅，而相互已知的sentinel之间只需要使用命令连接来通信就可以了
~~~

#### 检测主观下线

在默认情况，sentinelhi会以每一秒一次的频率向所有与它建立了命令连接的实例，（主服务器，从服务器，其他sentinel）发送ping命令，然后通过ping命令的返回来判断主观下线

实例只有返回+pong -loading -masterdown才算有效回复，sentinel配置文件中的down after milliseconds指定了setninel判断实例进入主观下线所需的时间长度，如果一个实例在down after milliseconds时间长度内连续向sentinel发送无效回复，那么sentinel会修改这个实例对应的实例结构，在结构的flags属性中打开SRI_s_down标识，以此来表示这个实例已经进入主观下线状态

当然用户在配置文件中配置的主观下线时间不仅会作为主服务器的主观下线时间判断，还会用作到所有的下属从服务器上。

另外需要注意的是多个sentinel设置的主观下线时间可能不同，也就是说一台主服务器假如被两台sentinel监控，那么其中一台设置的20000毫秒，其中一台设置的50000毫秒，那么可能出现一台判断是主观下线了，另一台判断还没有主观下线，这个机制是为客观下线判断做准备的

#### 检查客观下线

当一个sentinel将一个主服务器判断为主观下线时，它还需要确认这个服务器是否真的下线，也就是询问其他sentinel是否也都为主观下线，只有接收一定数量的主观下线后，sentinel就会将服务器判定为客观下线，并对下线的服务器执行故障转移操作

当数量达到配置指定的判断客观下线所需的数量时，sentinel就将主服务器结构的flags属性的SRI_O_DOWN标志打开，表示主服务器已经进入到了客观下线状态，需要开始sentinel最重要的作用--故障转移

sentinel monitor master 127.0.0.1 6379 2

表示包括当前sentinel在内，只要检测有两个sentinel服务器认为这个主服务器为主观下线状态，那么就会进入到客观下线状态，开始故障转移的过程

### 故障转移（重点）

#### 选举leader-sentinel（Raft算法）

当一个主服务器下线被判断为客观下线时，那么监视这个下线服务器的所有sentinel就会开始协商，选举出一个leader，并由leader对下线主服务器执行故障转移操作

下面是leader选举的规则与方法：

1.所有在线的sentinel都有资格成为leader

2.每次进行leader选举之后。不论选举是否成功，所有sentinel的配置纪元都会+1，配置纪元就是一个计数器

3.在一个配置纪元里，所有sentinel都要一次将某个sentinel设置为局部leader的机会，并且局部leader一旦设置，在这个配置纪元里就不能改变

4.每个发现主服务器进入客观下线的sentinel都会要求其他sentinel将自己设置为局部leader

5.当一个sentinel向另一个sentinel发送sentinel is master down by addr命令，这个命令的参数是一个runid，且是源sentinel的runid，表示源sentinel给别人发送消息，希望将自己选举为leader

6.由此可以看出sentinel的leader选举是一个先到先得的规则，最先发送投票请求的那个sentinel会成为leader，之后的都会被拒绝

7.如果某个sentinel会被半数以上的sentinel设置为局部领导人后，那么这个sentinel就会成为leader

8.因为leader的产生需要半数以上的投票，并且每个sentinel在每个配置纪元里只能设置一次局部leader，所以一个配置纪元里面，只会出现一个领头leader

9.如果在给定时间内没有成功选出leader，那么各个snetinel将在一段时间后再次进行选举，直到选出leader为止

~~~wiki
leader选举例子：
假设有三个sentinel，a,b,c
当确认进入客观下线后，开启领导选举，那么每一个sentinel都会向其他sentinel发送一个命令，sentinel is master down by addr runid，如果接收到这个命令的sentinel还没有将票投出去，那么就会将这个runid设置为自己的局部领头sentinel，并返回给一条命令，然后源sentinel收到返回以后做一个统计，只要超过了半数的sentinel都返回了结果，那么证明自己收到了半数投票，就会成为正式leader
~~~

#### 故障转移





