## 复制

在redsis中，用户可以通过slaveof + ip地址 + 端口号的方式在从服务器上执行，ip地址加端口号指定的是主服务器的，从而可以实现主从复制，去别的服务器复制的叫从服务器，提供给别人复制的是主服务器

进行主从复制的服务器之间应该保证数据的一致性。

### redis2.8以前的旧版复制原理

redis的复制功能可以分为同步和命令传播两部分：

1.同步操作用于将从服务器的状态更新到主服务器的状态

2.命令传播作用是在主服务器又增加了新的写命令后，需要将这个命令也传播给从服务器

#### 同步

当客户端向从服务器发送slaveof命令时，就是要求从服务器复制主服务器，那么从服务器需要首先进行一个同步操作，也就是将主服务器的状态更新到从服务器的，以此达到数据的一致性

从服务器对主服务器的同步操作是通过sync命令来完成的，步骤：

1.从服务器向主服务器发送sync命令

2.收到sync命令的主服务器开始执行bgsave命令，生成一个rdb文件，并使用一个缓冲区记录在生成rdb文件的这段时间新生成的写命令

3.当主服务器的bgsave执行完以后，主服务器会把这个生成的rdb文件发送给从服务器，从服务器载入这个rdb文件，主服务器还要发送缓冲区里面记录的写命令，从服务器收到以后执行完毕，这时候两个服务器的状态就达到了一致

#### 命令传播

经过同步后，两个服务器达到了短暂的一致，但是主服务器还会不断的接收新来的写命令，所以主服务器还要将命令传播到所有的从服务器，以此来维持住同步状态。

#### 旧版复制原理

在redis2.8以前，从服务器对主服务器的复制可以分为两种情况：

1.初次复制：从服务器以前没有复制过，或者当前要复制的主服务器和以前复制的主服务器不同

2.断线后重复制：处于命令传播阶段的主从服务器如果断开了网络连接，然后从服务器经过一段时间又恢复了网络连接，那么需要继续复制

对于初次复制，旧版的复制可以比较好的完成工作，但对于这个断线后重复制，旧版的效率太低下

因为断线重连后，从服务器还是使用sync命令进行完整复制，重复一遍生成rdb文件，写缓冲区等等这个流程，其实断线重连后只需要恢复断线的这个时间段主服务器新写进来的命令就OK了

~~~wiki
sync是一项非常耗费资源的操作
在复制的时候，每次执行sync命令，将会发生如下操作：
1.主服务器需要执行bgsave来生成rdb，这个操作会耗费大量主服务器的cpu，内存，磁盘io资源
2.主服务器需要将生成的rdb文件发送给从服务器，这个过程会耗费主从服务器大量的网络资源，并对主服务器的命令响应产生影响
3.接收到的rdb文件载入到从服务器，从服务器在rdb载入期间丧失所有读写能力
所以sync是一个很重的操作，所以尽量只在有必要的时候才执行sync
而断线重连恢复部分数据这种场景，很明显就不需要sync
~~~

#### 新版复制原理

新版使用psync代替sync

psync具有完整重同步和部分重同步两个功能

其中完整重同步用于处理初次复制情况，完整重同步的执行步骤和执行sync的步骤一样，都是让主服务器创建rdb文件，以及发送缓存区里面的写命令来进行同步

而部分重同步用于断线重连这种情况，当从服务器断线重连后，如果条件允许，主服务器将把断开后执行的命令发送给从服务器，从服务器只要接收并执行这些命令，就可以恢复到一致状态。

psync命令的部分重同步模式解决了旧版复制功能在处理断线能力方面效率低下的问题

#### 部分重同步的实现原理

部分重同步功能主要由三个部分组成：

1.主服务器的复制偏移量和从服务器的复制偏移量

2.主服务器的复制积压缓冲区

3.runid，每个服务器一个特定的id

复制偏移量

用来记录复制到了哪里，比如主服务器的offset是1000，从服务器的offset也是1000的话，那么说明两个服务器此时的状态是一致的。如果主服务器新增了写命令，那么offset会相应的增大。

如果在断线前主从服务器之间的复制偏移量是一致的，然后主从之间断开了连接，那么主服务器的偏移量会在这个阶段增加，当从服务器连接上来后将会向主服务器发送psync命令。

#### 复制积压缓冲区

复制积压缓冲区是一个由主服务器维护的FIFO先进先出的一个队列，并且大小默认是1M，长度是固定的，不会动态扩容

当主服务器进行命令传播的时候，不仅要把命令发送给所有的从服务器，还会将命令写入到复制积压缓冲区，复制积压缓冲区会保存部分最近发送的命令，并且复制积压缓冲区里面的每个字节都会对应一个准确的偏移量，用来做准确的部分重同步

当从服务器连接上来后，从服务器通过psync将自己的复制偏移量也带上，主服务器根据这个复制偏移量来决定进行哪种模式的psync

如果offset偏移量之后的数据仍然在缓冲区，那么进行部分重同步

如果offset偏移量之后的数据不在缓冲区了，说明已经断线很久了，那么复制积压缓冲区都已经没有存下，那么需要执行完整重同步

主服务器检查后发现应该是部分重同步，那么恢复一个+continue，然后主服务器会将积压缓冲区中这个偏移量后面的数据给从服务器发过去。从服务器只会接收丢失部分的数据，大大提高了断线复制的效率

另外这个积压缓冲区需要根据断线时间+主服务器写入速率的乘积来做一个设置

以此来尽量让所有的断线恢复都能在复制积压缓冲区中找到偏移量

#### 服务器运行ID

除了复制偏移量和复制积压缓冲区以外，实现部分重同步还需要带上runid，如果断线重连后从服务器发来的runid（发来的这个runid是保存的主服务器的runid）等于现在的主服务器id，那么说明断线前你的主服务器就是我，所以执行部分重同步，否则完整重同步

这个runid是当从服务器对主服务器进行初次复制时，主服务器会将自己的runid传送给从服务器，从服务器进行psync命令发送的时候需要带上这个runid。

psync的格式是 psync  runid offset，进行复制的时候除了确认这些参数以外，在真正复制之前还有一次握手的过程，+continue回复

#### 复制的完整实现

#### 1.设置主服务器的地址和端口号 salveof 127.0.0.1 6379

#### 2.建立socket连接

在slaveof命令执行以后，从服务器将根据命令所设置的ip地址和端口号，创建连向主服务器的套接字连接

如果从服务器创建的socket连接能成功连接到主服务器，那么从服务器将为这个套接字关联一个专门用于处理复制工作的文件事件处理器，这个处理器将负责执行之后的复制工作，比如接收rdb文件以及接收来的传播命令等

而主服务器在accept从服务器的套接字连接之后，将为该套接字创建相应的客户端状态，并将从服务器看做是一个客户端来对待，这时从服务器将具有服务器和客户端两个状态，从服务器可以向主服务器发送命令。

#### 3.发送ping命令

从服务器成为主服务器的客户端后，做的第一个事情就是发送ping命令，这个ping命令有两个作用：

1.虽然建立了套接字连接，但是双方并未使用该套接字进行任何网络通信，通过发送ping命令来检查套接字的读写状态是否正常

2.如果主服务器向从服务器返回一个命令回复，但从服务却不能在规定的时间内读取，当出现这种情况，需要断开连接

如果主服务器向从服务器返回一个错误，那么表示主服务器暂时没有办法处理从服务器的命令请求，不能执行复制的后序操作

如果从服务器读到了pong命令,那么表示主从服务器之间的网络连接状态是一致的,这种情况下,可以继续执行后序的复制操作

注意,如果ping后回复超时或者主服务器返回一个错误,那么从服务器会断开并重连

#### 4.身份验证

从服务器收到pong后,然后就是根据服务器的配置决定是否进行身份验证

masterauth和requirespass选项决定是否需要认证以及是否需要密码

#### 5.发送端口信息

身份验证后从服务器将向主服务器发送从服务器的监听端口号

主服务器在收到以后,会将端口号记录在从服务器对应的客户端状态的属性中

#### 6.同步

在这一步从服务器将向主服务器发送psync命令,执行同步操作.

需要注意的是在执行psync命令前只有从服务器是主服务的客户端,到了这一步,两者互为对方的客户端

正因为主服务器成为了从服务器的客户端,所以主服务器才可以通过发送写命令来改变从从服务器的状态

#### 7.命令传播

完成了同步后,就进入了命令传播阶段,这时主服务器只要一直将自己执行的写命令发送给从服务器,而从服务一直接收来自主服务器的命令,那么两者就可以一直是一致状态

### 心跳检测

在命令传播阶段,从服务器默认会以每秒一次的频率,向主服务器发送命令

replconf ack <replication offset>

其中replication offset就是从服务的当前复制偏移量

replconf ack 这个命令有三个作用:
1.检测主从网络连接状态

2.辅助实现min-slaves

3.检测命令丢失

第一点不用说,主要说二三点:
辅助实现min-slaves,redis的min-slaves-to-write和min-slaves-max-log选项可以让主服务器在不安全的情况下,停止写命令

min-slaves-to-write 设置为3,min-slaves-max-log设置为10,代表的意思从服务器的数量少于三个,或者三个从服务器的延迟值都大于或等于10,那么主服务器将拒绝执行写命令

另外replconf ack 后面带上的偏移量还可以检测在这一秒内主服务器有没有丢失命令

如果发现偏移量不一致,那么可能是主服务传播命令丢失了,需要补发数据

这个补发数据的原理和部分重同步的原理差不多,区别就是一个是断线了,一个没断线

在redis2.8以前,如果命令在传播过程中丢失了,那么主服务器和从服务器都不会注意到

所以为了保证数据的一致性,最好选用redis2.8以上版本

~~~wiki
复制部分总结:
部分重同步通过复制偏移量和复制积压缓冲区和runid三个来实现
在复制刚开始时,从服务器会成为主服务器的客户端,并通过向主服务器发送命令来执行复制的前面的步骤,而到了同步阶段,两者互为主从
并且还有心跳检测机制,防止数据丢失
~~~

## 哨兵

sentinel是redis高可用的解决方法，真实场景会有一个或多个sentinel实例组成的sentinel系统来监控任意多个主服务器，以及这些主服务器下的从服务器，并在被监视的主服务器下线后，自动将这个主服务器下的从服务器中的某一个升级为新的主服务器，这个下线的旧的主服务器会被sentinel设置为从服务器slave类型，如果重新上线了，那么它会作为一个从服务器，这个被称作故障转移

当某一个服务器的下线时长超过用户设置的下线时长上限时，sentinel系统就会对这个下线的服务器进行故障转移操作

首先sentinel系统会挑选它的属下的一台服务器，将这个服务器升级为主服务器

之后sentinel会向下线的服务器的所有下属发送复制命令，让他们成为新的主服务器的从服务器，当所有的从服务器都开始复制新的主服务器时，故障转移操作执行完毕

另外，sentinel还会继续监视已经下线的那个服务器，他重新上线后会成为新的主服务器的从服务器

启动一个sentinel的命令：redis-sentinel  ./././sentinel.conf

当一个sentinel启动的时候，它的步骤如下：

1.初始化服务器

2.将普通的redis服务器使用的命令表转换为sentinel服务器使用的命令表

3.初始化sentinel状态

4.根据给定的配置文件，初始化sentinel的监视主服务器列表

5.创建连向主服务器的网络连接

接下来详细总结启动sentinel的细节：

#### 初始化服务器

首先，sentinel本质上就是一个运行在特殊模式下的redis服务器，所以启动sentinel的第一步就是初始化一个普通的redis服务器，但是因为sentinel服务器的执行方式和redis服务器的不同，所以在初始化服务器的时候会有一些不同，比如redis服务器在初始化的时候需要载入rdb文件或者aof文件来还原数据库状态，而sentinel不使用数据库功能，所以sentinel服务器初始化的时候不载入aof和rdb文件

#### 使用sentinel专用代码

启动sentinel的第二步就是将一部分普通redis服务器使用的代码替换成sentinel的专用代码，比如端口号的配置常量，redis默认是6379，sentinel服务器默认是26379，除此以外，普通redis使用的命令表和sentinel服务器不同，实际上sentinel的命令表里面只有七个命令，也就是说客户端只能对sentinel使用7个命令：ping，sentinel，info，subscribe，unsubscribe，psubscribe，punsubscribe这七个命令，sentinel使用的命令表是sentinelcmds，普通redis服务器使用的命令表是rediscommandtable

#### 初始化sentinel状态

在应用了sentinel的专用代码后，服务器会初始化一个sentinel.c/sentinelState，简称sentinel状态，这个结构保存了服务器中和sentinel所有有关的配置，里面比较重要的是dict结构的masters，这是一个字典结构，字典键是主服务器的名字，值是一个指向sentinelredisinstance的实例。

#### 初始化sentinel状态中masters属性

这个masters属性表示了sentinel所监视的所有主服务器。从sentinel的介绍图上一般能看到sentinel也会监视到从服务器，但这里面没有保存从服务器的原因就是，由于主服务器会保存自己属下的所有从服务器，那么sentinel只要和主服务器建立了连接后，就可以从主服务器中拿到从服务器的信息，从而建立监视，其实就是两个连接，命令连接和订阅连接

说回字典结构，这个masters字典里保存了所有被sentinel监视的主服务器的相关信息

重点说字典的值，值指向的是主服务器的sentinelredisinstance结构，简称实例结构，这个实例结构可以是主服务器，从服务器，也可以是另一台sentinel实例，实例包含的属性的非常多：
flags：实例的类型，以及该实例的当前状态

name 实例名字，主服务器的名字由用户在配置文件中设置

runid：实例的运行id

config_epoch 配置纪元，用于实现故障转移的

addr：实例的地址

down after milliseconds 实例无响应多长时间后会被sentinel判断为主观下线，（非常重要）

。。。

对sentinel状态的初始化引发了对masters字典的初始化，而masters字典的初始化是根据被载入的sentinel配置文件来进行的，最终配置文件中信息会被载入到sentinel.c/sentinelState中的masters属性中，这个属性底层是字典实现的

#### 创建连向主服务器的网络连接

初始化sentinel的最后一步就是创建连接，sentinel将成为主服务器的一个客户端，它会向主服务器发送命令，并从命令回复中获取相关信息。需要注意的是：对于每个被sentinel监视的主服务器来说，sentinel都会和他们建立两个连接：
1.一个是专门用来发送命令的连接，并接受命令回复

2.另一个订阅连接，来订阅主服务器的sentinel hello频道

~~~wiki
为什么会有两个连接？
在redis目前（redis2.8）的发布订阅功能中，被发送的信息都不会保存在redis服务器里面，如果在信息发送时，想要接收信息的客户端不在线或者断线，那么这个信息就会丢失，因此为了不丢失sentinel hello频道中的任何信息，sentinel必须使用一个专用的订阅连接来接收该频道的信息
除了这个订阅连接必须存在以外，sentinel还必须向主服务器发送命令，以此来和主服务器进行通信，那么还必须建立命令连接
因为sentinel需要与多个服务器实例之间进行通信，所以sentinel使用的异步连接
~~~

以上就是sentinel服务器初始化的过程，至此sentinel服务器创建完成并与所有配置文件中配置好的主服务器之间建立起了连接

接下来就是sentinel与主服务器之间通信的细节：

#### 获取主服务器的信息

sentinel在正常状态下默认会以10秒一次的频率，向主服务器发送info命令，从命令回复中可以获取到主服务器本身的信息，以及这个主服务器的所有从服务器的信息，信息主要是记录了ip+端口号，状态online，offset以及lag，lag是响应时间

正因为可以通过这种方式获取到从服务器的信息，所以在玩的时候不需要在配置文件中配置从服务器的信息，就可以自动的发现从服务器，sentinel就会根据info回来的信息，对主服务器的结构实例sentinelredisinstance进行更新，至于主服务器返回来的所有从服务器信息，sentinel会将其更新到实例结构中的salves字典中去，这个salves字典中的键是sentinel自动设置的从服务器的名字，值是从服务器对应的实例结构

主服务器的实例结构的flags属性的值为SRI_master，从服务器的实例结构的flags属性的值是SRI_slave

主服务器的实例结构的name属性的值是sentinel配置文件中配置，从服务器的实例结构的name属性的值是sentinel系统根据从服务器的ip地址和端口号自动设置的

另外当sentinel发现主服务器有新的从服务器出现的时候，通过info命令的回复拿到新的从服务器信息，并将其设置在主服务器的sentinelredisinstance结构中的slaves字典中



~~~c
sentinelState{
	dict masters{
        主服务器名 ： sentinelredisinstance{
            				dict slaves{
                            		从服务器名 ： sentinelredisinstance
                        		}
    				}
}
~~~

#### 获取从服务的信息

当sentinel发现主服务器有新的从服务器出现时，sentinel除了会为这个新的从服务器创建相应的实例结构外，sentinel还会创建连接到从服务器的命令连接和订阅连接

每十秒一次的频率向主服务器发送info命令，根据info命令的回复，sentinel来提取一些信息，从这些信息中，sentinel对从服务器的实例结构进行更新

#### 向主服务器和从服务器发送信息

默认情况下，sentinel会每两秒一次的频率向sentinel hello频道发送消息。

#### 接收来自主服务器和从服务器的频道信息

当sentinel与一个主服务器或者从服务器建立起订阅连接后，sentinel就会通过订阅连接，向服务器发送 subcribe sentinel hello

sentinel对频道sentinel hello的订阅会一直持续到sentinel与服务器的连接断开为止

也就是说对于每个与sentinel连接的服务器，sentinel既能通过命令连接向服务器的sentinel hello 频道发送消息，也能订阅服务器的sentinel hello发来的消息

对于监视同一个服务器的多个sentinel来说，一个sentinel发送的消息也会被其他的sentinel接收到，这些消息会被用于更新其他sentinel对发送信息sentinel的认知，也会被用于更新其他sentinel对被监视服务器的认知

举个例子：假设现在有s1，s2，s3三台sentinel服务器在监视同一个服务器，那么当s1,向服务器的sentinel hello频道发送消息时，所有订阅了sentinel hello频道的sentinel包括自己都会收到这条消息，只不过如果自己发现这条消息是自己发送的，那么会丢弃，因为id相同

#### 更新sentinels字典

sentinel为主服务器创建的实例结构中的sentinels字典保存除sentinel本身外，还有所有同样监视了这个主服务器的sentinel信息

因为一个sentinel可以通过分析接收到的频道的信息来获知其他sentinel的存在，并通过发送频道信息来让其他sentinel知道自己的存在，所以用户在使用的sentinel的时候并不需要提供各个sentinel的地址信息，监视同一个主服务器的sentinel可以互相发现对方

sentinel之间也会创建连接，不过只会创建命令连接，不会创建订阅连接

~~~wiki
sentinel在连接主服务器或者从服务器的时候，需要创建订阅和命令连接，但是连接其他sentinel的时候只会创建命令，因为sentnel需要接收来自主服务器或者从服务器的频道信息，来发现未知的sentinel，所以才需要建立订阅，而相互已知的sentinel之间只需要使用命令连接来通信就可以了
~~~

#### 检测主观下线

在默认情况，sentinelhi会以每一秒一次的频率向所有与它建立了命令连接的实例，（主服务器，从服务器，其他sentinel）发送ping命令，然后通过ping命令的返回来判断主观下线

实例只有返回+pong -loading -masterdown才算有效回复，sentinel配置文件中的down after milliseconds指定了setninel判断实例进入主观下线所需的时间长度，如果一个实例在down after milliseconds时间长度内连续向sentinel发送无效回复，那么sentinel会修改这个实例对应的实例结构，在结构的flags属性中打开SRI_s_down标识，以此来表示这个实例已经进入主观下线状态

当然用户在配置文件中配置的主观下线时间不仅会作为主服务器的主观下线时间判断，还会用作到所有的下属从服务器上。

另外需要注意的是多个sentinel设置的主观下线时间可能不同，也就是说一台主服务器假如被两台sentinel监控，那么其中一台设置的20000毫秒，其中一台设置的50000毫秒，那么可能出现一台判断是主观下线了，另一台判断还没有主观下线，这个机制是为客观下线判断做准备的

#### 检查客观下线

当一个sentinel将一个主服务器判断为主观下线时，它还需要确认这个服务器是否真的下线，也就是询问其他sentinel是否也都为主观下线，只有接收一定数量的主观下线后，sentinel就会将服务器判定为客观下线，并对下线的服务器执行故障转移操作

当数量达到配置指定的判断客观下线所需的数量时，sentinel就将主服务器结构的flags属性的SRI_O_DOWN标志打开，表示主服务器已经进入到了客观下线状态，需要开始sentinel最重要的作用--故障转移

sentinel monitor master 127.0.0.1 6379 2

表示包括当前sentinel在内，只要检测有两个sentinel服务器认为这个主服务器为主观下线状态，那么就会进入到客观下线状态，开始故障转移的过程

### 故障转移（重点）

#### 选举leader-sentinel（Raft算法）

当一个主服务器下线被判断为客观下线时，那么监视这个下线服务器的所有sentinel就会开始协商，选举出一个leader，并由leader对下线主服务器执行故障转移操作

下面是leader选举的规则与方法：

1.所有在线的sentinel都有资格成为leader

2.每次进行leader选举之后。不论选举是否成功，所有sentinel的配置纪元都会+1，配置纪元就是一个计数器

3.在一个配置纪元里，所有sentinel都要一次将某个sentinel设置为局部leader的机会，并且局部leader一旦设置，在这个配置纪元里就不能改变

4.每个发现主服务器进入客观下线的sentinel都会要求其他sentinel将自己设置为局部leader

5.当一个sentinel向另一个sentinel发送sentinel is master down by addr命令，这个命令的参数是一个runid，且是源sentinel的runid，表示源sentinel给别人发送消息，希望将自己选举为leader

6.由此可以看出sentinel的leader选举是一个先到先得的规则，最先发送投票请求的那个sentinel会成为leader，之后的都会被拒绝

7.如果某个sentinel会被半数以上的sentinel设置为局部领导人后，那么这个sentinel就会成为leader

8.因为leader的产生需要半数以上的投票，并且每个sentinel在每个配置纪元里只能设置一次局部leader，所以一个配置纪元里面，只会出现一个领头leader

9.如果在给定时间内没有成功选出leader，那么各个snetinel将在一段时间后再次进行选举，直到选出leader为止

~~~wiki
leader选举例子：
假设有三个sentinel，a,b,c
当确认进入客观下线后，开启领导选举，那么每一个sentinel都会向其他sentinel发送一个命令，sentinel is master down by addr runid，如果接收到这个命令的sentinel还没有将票投出去，那么就会将这个runid设置为自己的局部领头sentinel，并返回给一条命令，然后源sentinel收到返回以后做一个统计，只要超过了半数的sentinel都返回了结果，那么证明自己收到了半数投票，就会成为正式leader
~~~

#### 故障转移

在选举产生了leader后，leader就会对已经下线的主服务器进行故障转移操作，主要包含以下步骤：

1.在下线的主服务器的属下中中挑出一个从服务器作为新的主服务器

2.让所有从服务器来复制这个新上任的主服务器

3.将下线的那个主服务器设置为新的主服务器的从服务器，从而在连上来以后成为从服务器

~~~wiki
新的主服务器的挑选：
leader会将所有从服务器放到一个列表中，然后按照规则，进行删除：
1.删除列表中所有已经下线的从服务器 保证列表中所有的服务器都是在线的
2.删除最近五秒内没有回复过leader info命令的服务器 保证所有服务器都是最近能正常通信的
3.删除所有与已下线服务器连接断开超过down after milliseconds * 10 的服务器，保证列表中的剩余服务器没有过早与主服务器断开连接，也就是数据比较新的
4.之后leader将根据优先级进行挑选，如果优先级相同，那么按照复制偏移量挑选，选出复制偏移量大的，如果还是没有选出来，那么选择runid最小的
~~~

选中了以后sentinel会向选中的服务器发送slave no one 命令，然后每秒一次的info命令来确认信息

~~~wiki
sentinel部分重点总结：
sentinel只是一个运行在特殊模式下的redis服务器，他使用了和普通redis不同的命令表
sentinel会读入用户配置文件，为每个要被监视的主服务器创建相应的实例结构，并创建连向主服务器的命令连接和订阅连接，而每个sentinel之间只会建立命令连接
在一般情况下，sentinel以每十秒一次的频率向被监视的主服务器和从服务器发送info命令
对于监视同一个主服务器和从服务器的多个sentinel来说，他们会以每两秒一次的频率，通过向被监视器的sentinel hello 频道发送消息向其他sentinel通知自己的存在
~~~

### 集群

集群是redis提供的分布式数据库解决方案，可以数据进行分片存储，当然集群的每个主节点也可以有自己的几个从节点，所以集群模式既能保证高并发，也能保证高可用

#### 节点

连接各个节点的工作可以使用cluster meet ip port命令完成，可以让node节点与ip与port指向的节点握手，当握手成功后，node节点就将这个所指向的节点加入到集群中

#### 启动节点

一个节点就是一个运行在集群模式下的redis服务器，redis服务器启动的时候会根据配置来判断是以普通模式还是以集群模式启动，集群模式的节点会继续使用普通模式下redis服务器的组件：
1.集群节点继续使用文件事件处理器来处理命令请求和返回命令回复

2.集群节点也会调用serverCron函数，而serverCron函数负责了clusterCron函数的定时调用，clusterCron负责在集群模式下向其他节点发送gossip协议的消息，以及检查节点是否断线等

3.集群节点依然会保存有数据库

4.aof模块与rdb模块依然正常工作

5.节点继续使用复制模块来进行节点的复制工作

除此以外节点继续使用redisserver结构保存服务器的状态。使用redisclient保存客户端的状态。在集群下用到的数据会保存在clusterNode结构，clusterlink结构以及clusterstate结构中

#### 集群数据结构（clusternode，clusterlink，clusterstate）

clusternode保存了一个节点的当前状态，比如节点的创建时间，节点的名字，节点当前的配置纪元，节点的ip地址和端口号。每个节点都会使用一个clusternode结构来记录自己的状态，并为集群中的其他节点（包括主节点和从节点）都创建一个相应的clusternode结构，以此来记录其他节点的信息

在clusternode结构中有一个指针是clusterlink，这个结构保存了连接节点所需的有关信息，比如socket描述符，输入缓冲区，输出缓冲区等

~~~wiki
redisclient和clusterlink结构有什么异同？
redisclientredisclient
和clusterlink结构都有自己的socket描述符和输入缓冲区以及输出缓冲区，这两个结构的区别在于redisclient结构中的套接字和缓冲区是用于连接客户端的，而clusterlink结构的中的套接字和缓冲区是用于连接节点的
~~~

最后每个节点还要保存一个clusterstate结构，这个结构记录了在当前节点的视角下，集群目前所处的状态，例如集群是上线状态还是下线状态，这个上线状态和下线状态的判断比较重要，涉及到所有的槽位有没有被装满的问题，clusterstate中还记录了集群中包含多少个节点，集群当前的配置纪元等信息，在clusterstate中维护了一个dict结构的nodes指针，这个字典中键为节点的名字，值为这个节点所对应的clusternode。myself指针指向当前节点

#### cluster meet命令的实现

通过向一个节点发送cluster meet命令，客户端可以让接收命令的节点将这个参数后面跟着的节点加入到自己的集群中，收到命令的节点将与目标节点进行一次握手，以此来确认彼此的存在，并为将来的通信打好基础

1.讲点A将为B创建一个clusternode结构，并将这个结构添加到自己的clusterState结构的nodes字典里

2.之后节点A将根据cluster meet后面带的ip地址和端口号，向节点B发送一条meet信息

3.如果节点B收到了meet信息，节点B也会为A创建一个clusternode结构，添加到nodes字典里

4.之后B向A回复pong消息

5.节点A收到pong消息后就知道节点B成功收到了自己的meet消息

6.之后节点A再向B发送ping消息

7.节点B收到A发来的ping，完成握手

之后节点A会将节点B的信息通过gossip协议传播到集群中已经存在的其他节点，让其他节点也与B进行握手，至此集群内所有节点互相认识

#### 槽指派

redis集群通过分片的方式来保存数据库中的键值对，集群的整个数据库被分为了16384个槽，数据库中的每个键都属于这16384个槽位中的某一个，集群中的每个节点最多会访问0-16384个槽。

如果集群中有一个槽位没有得到处理，也就是没有主节点来对这个槽进行占用，主节点与从节点最大的区别就是主节点在集群中作用是处理槽，从节点只是复制主节点中的内容，如果有一个槽位没有主节点来处理，那么整个集群就是下线状态，反之为上线状态

通过cluster addslot （slot）命令来指派槽位

为了让整个集群处于上线状态，我们需要将16384个槽位给所有节点分配出去

在clusternode结构中的slots属性和numslot属性记录了当前节点负责处理哪些槽

slots属性是一个二进制位数组，这个数组的长度是16384 / 8 = 2048个字节，其中包含了16384个二进制位。

那么如果在这个节点的clusternode中的slots属性的某个槽位上的二进制位为1，那么说明当前节点负责了这个槽位

如果为0，那么就是不处理，这个槽位是其他的节点来处理，因为取出slots数组中的任意一个二进制位的值的时间复杂复杂度为O1，所以对于一个给定节点的slots数组来说，程序检查这个节点是否处理这个槽位是很快的，至于numslot的值则记录了节点负责处理的槽位的数量

#### 传播节点的槽指派信息

一个节点除了会将自己负责处理的槽记录在clusterNode结构中slots属性和numslot中外，还会将自己的slots数组通过消息发送给集群中的其他节点，以此来告知其他节点目前自己负责处理哪些槽

通俗点就是三个节点的集群中，节点1会将自己的slots数组发给节点2和节点3，以此来告知另外两个节点自己负责处理的槽位

当节点2通过消息从节点1那里拿到了节点1的数组时，节点2会在自己的clusterstate的nodes属性中查找节点节点1所对应的clusternode结构，对结构中的slots数组进行更新或者保存

通过这种机制，集群中的所有节点都会知道其他节点所处理的槽信息

#### 记录集群中所有槽指派信息

clusterstate结构中的slots数组记录了集群中所有16384个槽的指派信息

clusterstate中的slots数组包含16384个项，每一项都是一个指向clusternode结构的指针

如果slots的某一个位置指向为null，说明该槽未被分配给任何节点，如果指向一个clusternode结构，说明这个槽是被这个clusternode结构所代表的节点处理

如果只是将槽指派信息保存到各个节点的clusternode的slots数组中的话，会出现一些无法高效解决的问题

clusterstate的slots数组解决了这些问题：

如果每个节点只是再clusternode中的slots数组中保存槽信息，那么为了知道某一个节点是否被分配或者被分配给了哪个节点，就需要从clusternode的nodes字典中查所有的clusternode结构，然后遍历这些结构中的clusternode中的slots结构，这是一个比较麻烦的操作

而使用了clusterstate中的slots数组，这个数组里面每一个槽位都指向一个clusternode结构，而我们说clusternode结构就是节点的详细信息，有ip地址和端口号，所以可以很快的知道这个槽是被哪个节点处理的，其实就是一种很常见的以空间换时间的做法

#### cluster addslots命令

cluster addslots后面指定一些槽位，来将这些输入的槽位指派给接收该命令的节点负责

在cluster addslots执行完成以后，需要告知集群中的其他节点当前节点处理的slots

#### 集群中执行命令

在集群中16384个槽都进行了指派后，集群就会进入上线状态，这时客户端就可以向集群中的节点发送命令

当客户端向节点发送与数据库有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽位，并检查这个槽位是否指派给了自己，如果键所在的槽正好指向了自己，那么节点就直接执行这个命令

如果键所在的槽没有指派给当前节点，那么节点会向客户端返回一个moved错误，指引客户端转向正确的节点，就是一个重定向的过程。这个moved错误不会在客户端显示出来，会直接自动转发到正确节点redirect to slot located at ip port

~~~wiki
客户端向节点发送数据库键命令
节点计算键属于哪个槽
如果当前节点就是负责处理这个键的节点，那么直接处理，否则返回moved（不显示）会自动重定向到正确的节点上

计算键属于哪个槽的算法是：
通过 crc16来计算键key的crc16检验和，然后 & 16383
cluster keyslot key就是使用这种方式实现的	
至于说添加节点的时候这个槽位是这么算的，其实很简单，在随便使用一个节点进行set操作的时候，这个key会被函数计算到一个槽里，然后集群会自动重定向到那个槽位的负责节点，下次get就是在那个节点上get，因为整个集群都会更新结构，从而知道哪一个key在哪个槽上

当计算出键所属的槽后，节点就要检查自己在clusterstate的slots数组中的项i，判断键所咋的槽是否是自己负责
如果clusterstate的slots【i】 = clusterstate.myself，那么说明槽i由当前节点负责，节点可以执行客户端发送的命令
不等的话节点会根据slots的指向clusternode结构所记录的ip和端口号，返回moved（其实不可见）自动重定向到正确的节点
~~~

#### moved错误

当节点发现键所在的槽并非由自己处理的时候，节点会向客户端返回一个moved错误，引导客户端转向正在负责槽的节点

一个集群客户端通常会与集群中的多个节点创建套接字连接，而所谓的节点转向就是换一个套接字来处理

为什么说是被隐藏的moved错误，是因为redis客户端并不会打印出来moved错误，而是根据moved返回的ip 和port进行自动节点转向，会打印出转向信息，所以我们是看不见节点返回的moved错误

#### 节点的数据库实现

集群保存节点键值对以及键值对过期时间的方式，与redis单机服务保存键值对一样

唯一的区别是集群节点只能使用0号库，普通节点无所谓

另外还有一个特点之处是除了将节点保存在数据库里面，节点还会用clusterstate结构中的slots_to_keys跳跃表来保存槽和键之间的关系

在这个跳表中，分值表示是槽位，成员member表示的是每一个数据库键，通过在跳表中使用槽位的方式记录数据库键，我们可以很快的找到属于某个或某些槽的键，我们可以很方便的对某一个槽中的数据或者某些槽中的数据进行批量操作。

#### 重新分片

当在一个集群中添加一个新的节点进来时，就需要进行重新分片，重新分片可以在线进行，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求

~~~wiki
重新分片的原理：
redis-tribredis-trib
redis-trib对集群中的单个槽进行重新分片的过程如下：
1.redis-trib对目标节点发送cluster setslot importing命令，让目标节点准备好从源节点导入import属于槽slot的键值对
2.redis-trib对源节点发送cluster setslot migrating命令，让源节点准备好迁移
3.redis-trib让源节点发送cluster getkeysinslot命令，获取最多count个属于槽slot的键值对的键名
4.对于上一步获得的每个键名，再次发送migrate命令，将被选中的键原子的从源节点迁移至目标节点
5.重复3,4
6.redis-trib向集群中的任意一个节点发送cluster set slot node命令，将槽slot指派给目标节点，这一指派信息将会通过消息发送至整个集群中，最终集群所有节点都会知道槽slot已经指派给了目标节点

流程图：
开始对槽slot进行重新分片
目标节点准备导入槽slot中的键值对
源节点准备迁移slot键值对
源节点是否保存了属于槽slot的键
是的话将这些键全部迁移至目标节点，不是的话将槽指派给目标节点
完成分片
~~~

ASK错误

在重分片的时候，源节点向目标节点迁移一个槽的过程中，可能会出现被迁移槽的一部分键值对保存在目标节点里，一部分在源节点里，这时候客户端向源节点发送来一个请求，并且请求要处理的数据正好就是重新分片的时候正在被迁移的槽

源节点会现在自己的数据库里面查找指定的键，如果找的到的话，直接返回。否则就是有可能这个键已经被迁移到了目标节点，所以源节点会向客户端返回一个ask错误，当然这也是一个隐藏式错误，客户端会被自动转到被迁移后的节点中去

ack错误就是节点收到了一个关于键key的命令请求，并且键key所属的槽i正好就指派给了这个节点，那么节点会尝试在自己的数据库里查询键key，找到了话就执行客户端的命令，如果没找到，但是明明这个键key就是属于你这个节点管辖的啊，其实可能就是因为这个槽位正在进行迁移，这个槽位中的键将来都不会再归这个节点关了，所以爆出ack错误。这是隐藏式错误，会引导到正确的节点中去查询

~~~wiki
ack错误和moved错误区别：
ack错误和moved错误都会导致客户端转向。区别是
moved错误代表槽的负责权已经从一个节点转移到了另一个节点上，在客户端收到关于槽i的moved错误后，客户端每次遇到关于槽i的请求都会直接将命令发送至moved错误所指向的节点，因为该节点是目前负责槽i的节点
与此相反，ack错误只是两个节点在迁移槽的过程中使用的一种临时措施。在客户端收到关于槽i的ask错误时，客户端只会在接下来一次命令请求中将关于槽i的命令重定向到错误指示的节点，但是这种转向不会对客户端之后发送的命令产生影响，客户端仍然会将关于槽i的命令请求发送至目前负责处理槽i的节点，除非ask错误再次出现
~~~

#### 复制与故障转移

redis集群中的节点分为主节点和从节点，主节点用于处理槽，做分布式存储，从节点仅是复制主节点，做高可用，在主节点下线后在这些从节点中挑选出新的主节点。比如说集群中目前有四个主节点，其中一个主节点有两个从节点，那么当这个主节点下线后，其他的主节点需要在这两个从节点中挑选出一个作为新的主节点，新的主节点将接管原来主节点的槽位，下线后的这个主节点上线后将成为刚才新上任的那个主节点的从节点

#### 节点的复制

集群中设置从节点就是复制的过程，cluster replicate node id 

一个节点成为从节点，并开始复制某个主节点这一信息将会通过消息发送给集群中的其他节点，最终集群中的所有节点都会知道某个从节点正在复制某个主节点

#### 故障检测

集群中的每个节点都会定期地向集群中的其他节点发送ping消息，以此来检测对方是否在线，如果接收ping消息的节点没在规定时间内，向发送ping消息的节点返回pong信息，那么发送ping消息的节点就会把接收ping消息的节点标记为疑似下线状态

集群中各个节点会通过互相发送消息的方式来交换集群中各个节点的状态信息，例如某个节点是否处于在线状态，疑似下线状态，下线状态，同样的，对于集群来说跟sentinel很像，如果在一个集群里面，半数以上负责处理槽的主机都将某个主节点报告为疑似下线，那么这个主节点就会被标志为已下线，然后会将这个已下线的消息广播出去

#### 故障转移

当一个从节点发现自己正在复制的主节点进入了已下线状态时，从节点就开始对下线主节点进行故障转移操作：
1.这个下线的主节点的所有从节点里面，会有一个从节点被选择出来（新的主节点选举算法）

2.被选中的从节点会执行slave on one命令，成为新的主节点

3.新的主节点会撤销已下线主节点的所有槽指派，并将这些槽指派给自己

4.新的主节点向集群里广播pong消息，这条pong消息可以让集群中的其他所有节点立即知道这个节点已经变成了新的主节点，并且已经接管了所有的槽

5.新的主节点开始接收和处理自己负责的槽的有关命令，故障转移完成

#### 新的主节点选举算法

1.集群的配置纪元是一个自增计数器，初始值是0

2.当集群里的某个节点开始一次故障转移时，集群配置纪元的值会加1

3.对于每一个配置纪元，集群每个主节点都有一次投票权，而第一个向主节点要求投票（拉票）从节点会获得主节点的这一张唯一的票，就是配置纪元

4.当从节点发现自己正在复制的主节点进入已下线状态，从节点会向集群中广播一条命令，其实就是获取投票的意思，要求所有收到这个消息的主节点，把票投给这个从节点

5.所以这个算法依然是看发送的速度来投票的

6.每个从节点都会拉票，并且根据主节点返回来的消息，统计自己收到了多少张票

7.如果这个集群里有N个具有投票权的主节点，那么如果有一个从从节点收到的票数是N/2+1，由于每个主节点只会投一次票，所以确保不会产生一个以上的主节点

9.如果在一轮投票中没有一个主节点产生，那么进入一个新的配置纪元，再次进行选举，直到选出新的主节点

##### 集群的故障主节点掉线后新的主节点选取算法和sentinel的领头sentinel选取算法都是基于Raft算法的来实现的

~~~wiki
集群重点回顾：
1.节点通过握手来将其他节点添加到自己所处的集群中
2.集群中的16384个槽可以分别指派给集群中的各个节点，每个节点会记录哪些槽指派给了自己，哪些槽指派给了其他节点
3.节点在收到一个命令请求后，会先检查这个命令请求要处理的键所在的槽是否由自己负责，如果不是的话，发生moved错误，根据moved错误的提示信息，然后自动重定向到正在负责相关槽的节点
4.对redis集群的重分片是通过redis-trib执行的，重分片的关键是将属于某个槽的键值对从一个节点转移到另一个节点
5.如果节点A正在迁移槽i至节点B，那么当节点A没能在自己的数据库中找到命令指定的数据库键时，节点A向客户端返回一个ask错误，指引客户端到节点B继续查询指定的数据库键
6.moved错误表示槽的负责权已经从一个节点转移到了另一个节点，而ask错误只是两个节点在迁移槽的时候使用的一种临时措施
~~~



